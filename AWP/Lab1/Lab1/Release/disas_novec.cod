; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	d:\univer\6 sem\awp\lab1\lab1\source.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_06MALMBFOP@?5ticks@			; `string'
PUBLIC	??_C@_0L@HNBJPKEP@auto_vec?3?5@			; `string'
PUBLIC	??_C@_08MLBKJEKP@my_vec?3?5@			; `string'
PUBLIC	??_C@_0M@NADFNJG@pause?5?$DO?5NUL@		; `string'
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp____std_terminate:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp__GetTickCount64@0:PROC
EXTRN	__imp__system:PROC
EXTRN	__imp___aligned_malloc:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp__srand:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
;	COMDAT ??_C@_0M@NADFNJG@pause?5?$DO?5NUL@
CONST	SEGMENT
??_C@_0M@NADFNJG@pause?5?$DO?5NUL@ DB 'pause > NUL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLBKJEKP@my_vec?3?5@
CONST	SEGMENT
??_C@_08MLBKJEKP@my_vec?3?5@ DB 'my_vec: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HNBJPKEP@auto_vec?3?5@
CONST	SEGMENT
??_C@_0L@HNBJPKEP@auto_vec?3?5@ DB 'auto_vec: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MALMBFOP@?5ticks@
CONST	SEGMENT
??_C@_06MALMBFOP@?5ticks@ DB ' ticks', 00H		; `string'
CONST	ENDS
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	_main
PUBLIC	?init_matrix@@YAXAAPAPAPAPAMHH_N@Z		; init_matrix
PUBLIC	?my_vectorize@@YAXPAPAPAPAM00@Z			; my_vectorize
PUBLIC	?auto_vectorize@@YAXPAPAPAPAM00@Z		; auto_vectorize
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$dead$ = ecx

; 536  :             return _time64(_Time);

  00000	6a 00		 push	 0
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00008	83 c4 04	 add	 esp, 4

; 537  :         }

  0000b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
;	COMDAT ?auto_vectorize@@YAXPAPAPAPAM00@Z
_TEXT	SEGMENT
_right$1$ = -52						; size = 4
_left$1$ = -48						; size = 4
tv1522 = -44						; size = 4
tv1520 = -40						; size = 4
tv1519 = -36						; size = 4
tv1525 = -32						; size = 4
tv1518 = -28						; size = 4
tv1528 = -24						; size = 4
tv1526 = -20						; size = 4
tv1536 = -16						; size = 4
tv1530 = -12						; size = 4
tv1537 = -8						; size = 4
tv1529 = -4						; size = 4
_res$ = 8						; size = 4
?auto_vectorize@@YAXPAPAPAPAM00@Z PROC			; auto_vectorize, COMDAT
; _left$ = ecx
; _right$ = edx

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 16   : 	for (int i = 0; i < N; i++)

  00006	8b 45 08	 mov	 eax, DWORD PTR _res$[ebp]
  00009	2b c8		 sub	 ecx, eax
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	89 55 cc	 mov	 DWORD PTR _right$1$[ebp], edx
  00010	89 4d d0	 mov	 DWORD PTR _left$1$[ebp], ecx
  00013	c7 45 e8 80 00
	00 00		 mov	 DWORD PTR tv1528[ebp], 128 ; 00000080H
  0001a	57		 push	 edi
  0001b	eb 03 8d 49 00	 npad	 5
$LL4@auto_vecto:

; 17   : 		for (int j = 0; j < N; j++)

  00020	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  00023	8b 18		 mov	 ebx, DWORD PTR [eax]
  00025	8b c2		 mov	 eax, edx
  00027	2b c1		 sub	 eax, ecx
  00029	89 4d d8	 mov	 DWORD PTR tv1520[ebp], ecx
  0002c	33 d2		 xor	 edx, edx
  0002e	89 5d d4	 mov	 DWORD PTR tv1522[ebp], ebx
  00031	89 45 ec	 mov	 DWORD PTR tv1526[ebp], eax
  00034	89 55 fc	 mov	 DWORD PTR tv1529[ebp], edx
$LL7@auto_vecto:

; 18   : 			for (int k = 0; k < N; k++)

  00037	8b 3c 13	 mov	 edi, DWORD PTR [ebx+edx]
  0003a	89 7d dc	 mov	 DWORD PTR tv1519[ebp], edi
  0003d	89 4d f4	 mov	 DWORD PTR tv1530[ebp], ecx
  00040	c7 45 f0 80 00
	00 00		 mov	 DWORD PTR tv1536[ebp], 128 ; 00000080H
  00047	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL10@auto_vecto:

; 19   : 				for (int a = 0; a < K; a++)

  00050	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  00053	8b f7		 mov	 esi, edi
  00055	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR tv1537[ebp], 4
  0005c	8b 1c 02	 mov	 ebx, DWORD PTR [edx+eax]
  0005f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00061	2b c7		 sub	 eax, edi
  00063	89 5d e0	 mov	 DWORD PTR tv1525[ebp], ebx
  00066	89 45 e4	 mov	 DWORD PTR tv1518[ebp], eax
  00069	8d a4 24 00 00
	00 00		 npad	 7
$LL13@auto_vecto:

; 20   : 					for (int c = 0; c < K; c++)

  00070	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00073	8b fb		 mov	 edi, ebx

; 21   : 						for (int b = 0; b < K; b++)
; 22   : 							res[i][j][a][b] += left[i][k][a][c] * right[k][j][c][b];

  00075	8b 16		 mov	 edx, DWORD PTR [esi]
  00077	2b f9		 sub	 edi, ecx
  00079	bb 04 00 00 00	 mov	 ebx, 4
  0007e	8b ff		 npad	 2
$LL16@auto_vecto:
  00080	8b 04 39	 mov	 eax, DWORD PTR [ecx+edi]
  00083	d9 00		 fld	 DWORD PTR [eax]
  00085	d8 09		 fmul	 DWORD PTR [ecx]
  00087	d8 02		 fadd	 DWORD PTR [edx]
  00089	d9 1a		 fstp	 DWORD PTR [edx]
  0008b	d9 40 04	 fld	 DWORD PTR [eax+4]
  0008e	d8 09		 fmul	 DWORD PTR [ecx]
  00090	d8 42 04	 fadd	 DWORD PTR [edx+4]
  00093	d9 5a 04	 fstp	 DWORD PTR [edx+4]
  00096	d9 40 08	 fld	 DWORD PTR [eax+8]
  00099	d8 09		 fmul	 DWORD PTR [ecx]
  0009b	d8 42 08	 fadd	 DWORD PTR [edx+8]
  0009e	d9 5a 08	 fstp	 DWORD PTR [edx+8]
  000a1	d9 40 0c	 fld	 DWORD PTR [eax+12]
  000a4	d8 09		 fmul	 DWORD PTR [ecx]
  000a6	83 c1 04	 add	 ecx, 4
  000a9	d8 42 0c	 fadd	 DWORD PTR [edx+12]
  000ac	d9 5a 0c	 fstp	 DWORD PTR [edx+12]
  000af	83 eb 01	 sub	 ebx, 1
  000b2	75 cc		 jne	 SHORT $LL16@auto_vecto

; 19   : 				for (int a = 0; a < K; a++)

  000b4	8b 45 e4	 mov	 eax, DWORD PTR tv1518[ebp]
  000b7	83 c6 04	 add	 esi, 4
  000ba	83 6d f8 01	 sub	 DWORD PTR tv1537[ebp], 1
  000be	8b 5d e0	 mov	 ebx, DWORD PTR tv1525[ebp]
  000c1	75 ad		 jne	 SHORT $LL13@auto_vecto

; 18   : 			for (int k = 0; k < N; k++)

  000c3	8b 4d f4	 mov	 ecx, DWORD PTR tv1530[ebp]
  000c6	8b 55 fc	 mov	 edx, DWORD PTR tv1529[ebp]
  000c9	83 c1 04	 add	 ecx, 4
  000cc	83 6d f0 01	 sub	 DWORD PTR tv1536[ebp], 1
  000d0	8b 7d dc	 mov	 edi, DWORD PTR tv1519[ebp]
  000d3	8b 45 ec	 mov	 eax, DWORD PTR tv1526[ebp]
  000d6	89 4d f4	 mov	 DWORD PTR tv1530[ebp], ecx
  000d9	0f 85 71 ff ff
	ff		 jne	 $LL10@auto_vecto

; 17   : 		for (int j = 0; j < N; j++)

  000df	8b 4d d8	 mov	 ecx, DWORD PTR tv1520[ebp]
  000e2	83 c2 04	 add	 edx, 4
  000e5	8b 5d d4	 mov	 ebx, DWORD PTR tv1522[ebp]
  000e8	89 55 fc	 mov	 DWORD PTR tv1529[ebp], edx
  000eb	81 fa 00 02 00
	00		 cmp	 edx, 512		; 00000200H
  000f1	0f 8c 40 ff ff
	ff		 jl	 $LL7@auto_vecto

; 16   : 	for (int i = 0; i < N; i++)

  000f7	8b 45 08	 mov	 eax, DWORD PTR _res$[ebp]
  000fa	8b 4d d0	 mov	 ecx, DWORD PTR _left$1$[ebp]
  000fd	83 c0 04	 add	 eax, 4
  00100	83 6d e8 01	 sub	 DWORD PTR tv1528[ebp], 1
  00104	8b 55 cc	 mov	 edx, DWORD PTR _right$1$[ebp]
  00107	89 45 08	 mov	 DWORD PTR _res$[ebp], eax
  0010a	0f 85 10 ff ff
	ff		 jne	 $LL4@auto_vecto

; 23   : }

  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c3		 ret	 0
?auto_vectorize@@YAXPAPAPAPAM00@Z ENDP			; auto_vectorize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
;	COMDAT ?my_vectorize@@YAXPAPAPAPAM00@Z
_TEXT	SEGMENT
_left$1$ = -28						; size = 4
tv673 = -24						; size = 4
tv671 = -20						; size = 4
tv674 = -16						; size = 4
_right$1$ = -12						; size = 4
tv668 = -8						; size = 4
tv672 = -4						; size = 4
_res$ = 8						; size = 4
?my_vectorize@@YAXPAPAPAPAM00@Z PROC			; my_vectorize, COMDAT
; _left$ = ecx
; _right$ = edx

; 25   : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 20	 sub	 esp, 32			; 00000020H

; 26   : 	for (int i = 0; i < N; i++)

  00019	8b 43 08	 mov	 eax, DWORD PTR _res$[ebx]
  0001c	2b c8		 sub	 ecx, eax
  0001e	56		 push	 esi
  0001f	8b f2		 mov	 esi, edx
  00021	89 4d e4	 mov	 DWORD PTR _left$1$[ebp], ecx
  00024	57		 push	 edi
  00025	89 75 f4	 mov	 DWORD PTR _right$1$[ebp], esi
  00028	c7 45 ec 80 00
	00 00		 mov	 DWORD PTR tv671[ebp], 128 ; 00000080H
  0002f	90		 npad	 1
$LL4@my_vectori:

; 27   : 		for (int j = 0; j < N; j++)

  00030	03 c8		 add	 ecx, eax
  00032	33 d2		 xor	 edx, edx
  00034	89 4d f8	 mov	 DWORD PTR tv668[ebp], ecx
  00037	89 55 fc	 mov	 DWORD PTR tv672[ebp], edx
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL7@my_vectori:

; 28   : 			for (int k = 0; k < N; k++)

  00040	33 ff		 xor	 edi, edi
  00042	89 7d f0	 mov	 DWORD PTR tv674[ebp], edi
$LL10@my_vectori:

; 29   : 				for (int a = 0; a < K; a++)

  00045	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00048	33 f6		 xor	 esi, esi
  0004a	89 45 e8	 mov	 DWORD PTR tv673[ebp], eax
  0004d	8d 49 00	 npad	 3
$LL13@my_vectori:

; 30   : 					for (int c = 0; c < K; c++) {

  00050	33 c0		 xor	 eax, eax
$LL16@my_vectori:

; 31   : 						__m128 const_value = _mm_set1_ps(left[i][k][a][c]);

  00052	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00054	8b 0c 0f	 mov	 ecx, DWORD PTR [edi+ecx]

; 32   : 						for (int b = 0; b < K; b += 4) {
; 33   : 							__m128 string_value = _mm_load_ps(&right[k][j][c][b]);

  00057	8b 7d fc	 mov	 edi, DWORD PTR tv672[ebp]
  0005a	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  0005d	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]

; 34   : 							__m128 res_value = _mm_load_ps(&res[i][j][a][b]);
; 35   : 							res_value = _mm_add_ps(res_value, _mm_mul_ps(string_value, const_value));
; 36   : 							_mm_store_ps(&res[i][j][a][b], res_value);

  00062	8b 4b 08	 mov	 ecx, DWORD PTR _res$[ebx]
  00065	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00069	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0006b	8b 0c 11	 mov	 ecx, DWORD PTR [ecx+edx]
  0006e	8b 14 0e	 mov	 edx, DWORD PTR [esi+ecx]
  00071	8b 4d e8	 mov	 ecx, DWORD PTR tv673[ebp]
  00074	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00076	8b 0c 0f	 mov	 ecx, DWORD PTR [edi+ecx]
  00079	8b 7d f0	 mov	 edi, DWORD PTR tv674[ebp]
  0007c	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  0007f	83 c0 04	 add	 eax, 4
  00082	0f 10 09	 movups	 xmm1, XMMWORD PTR [ecx]
  00085	8b 4d f8	 mov	 ecx, DWORD PTR tv668[ebp]
  00088	0f 59 c8	 mulps	 xmm1, xmm0
  0008b	0f 58 0a	 addps	 xmm1, XMMWORD PTR [edx]
  0008e	0f 11 0a	 movups	 XMMWORD PTR [edx], xmm1
  00091	8b 55 fc	 mov	 edx, DWORD PTR tv672[ebp]
  00094	83 f8 10	 cmp	 eax, 16			; 00000010H
  00097	7c b9		 jl	 SHORT $LL16@my_vectori

; 29   : 				for (int a = 0; a < K; a++)

  00099	83 c6 04	 add	 esi, 4
  0009c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0009f	7c af		 jl	 SHORT $LL13@my_vectori

; 28   : 			for (int k = 0; k < N; k++)

  000a1	8b 75 f4	 mov	 esi, DWORD PTR _right$1$[ebp]
  000a4	83 c7 04	 add	 edi, 4
  000a7	89 7d f0	 mov	 DWORD PTR tv674[ebp], edi
  000aa	81 ff 00 02 00
	00		 cmp	 edi, 512		; 00000200H
  000b0	7c 93		 jl	 SHORT $LL10@my_vectori

; 27   : 		for (int j = 0; j < N; j++)

  000b2	83 c2 04	 add	 edx, 4
  000b5	89 55 fc	 mov	 DWORD PTR tv672[ebp], edx
  000b8	81 fa 00 02 00
	00		 cmp	 edx, 512		; 00000200H
  000be	7c 80		 jl	 SHORT $LL7@my_vectori

; 26   : 	for (int i = 0; i < N; i++)

  000c0	8b 43 08	 mov	 eax, DWORD PTR _res$[ebx]
  000c3	8b 4d e4	 mov	 ecx, DWORD PTR _left$1$[ebp]
  000c6	83 c0 04	 add	 eax, 4
  000c9	83 6d ec 01	 sub	 DWORD PTR tv671[ebp], 1
  000cd	89 43 08	 mov	 DWORD PTR _res$[ebx], eax
  000d0	0f 85 5a ff ff
	ff		 jne	 $LL4@my_vectori

; 37   : 						}
; 38   : 					}
; 39   : }

  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	8b e5		 mov	 esp, ebp
  000da	5d		 pop	 ebp
  000db	8b e3		 mov	 esp, ebx
  000dd	5b		 pop	 ebx
  000de	c3		 ret	 0
?my_vectorize@@YAXPAPAPAPAM00@Z ENDP			; my_vectorize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
;	COMDAT ?init_matrix@@YAXAAPAPAPAPAMHH_N@Z
_TEXT	SEGMENT
tv361 = -24						; size = 8
tv381 = -16						; size = 8
tv372 = -16						; size = 8
tv382 = -12						; size = 4
tv373 = -12						; size = 4
tv367 = -12						; size = 4
_matrix$1$ = -8						; size = 4
tv357 = -4						; size = 4
_k$dead$ = 8						; size = 4
_is_rand$ = 12						; size = 1
?init_matrix@@YAXAAPAPAPAPAMHH_N@Z PROC			; init_matrix, COMDAT
; _matrix$ = ecx
; _n$dead$ = edx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  0000b	6a 00		 push	 0
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 42   : {

  0000d	89 7d f8	 mov	 DWORD PTR _matrix$1$[ebp], edi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 43   : 	srand(time(0));

  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand

; 44   : 	matrix = (float****)_aligned_malloc(n * sizeof(float***), 16);

  0001d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp___aligned_malloc
  00023	6a 10		 push	 16			; 00000010H
  00025	68 00 02 00 00	 push	 512			; 00000200H
  0002a	ff d3		 call	 ebx
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	89 07		 mov	 DWORD PTR [edi], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  00031	33 f6		 xor	 esi, esi
  00033	89 75 fc	 mov	 DWORD PTR tv357[ebp], esi
$LL4@init_matri:
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 46   : 		matrix[i] = (float***)_aligned_malloc(n * sizeof(float**), 16);

  00036	6a 10		 push	 16			; 00000010H
  00038	68 00 02 00 00	 push	 512			; 00000200H
  0003d	ff d3		 call	 ebx
  0003f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00041	83 c4 08	 add	 esp, 8
  00044	33 db		 xor	 ebx, ebx
  00046	89 04 0e	 mov	 DWORD PTR [esi+ecx], eax
  00049	8d a4 24 00 00
	00 00		 npad	 7
$LL7@init_matri:

; 48   : 			matrix[i][j] = (float**)_aligned_malloc(k * sizeof(float*), 16);

  00050	6a 10		 push	 16			; 00000010H
  00052	6a 10		 push	 16			; 00000010H
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0005a	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0005c	83 c4 08	 add	 esp, 8
  0005f	33 ff		 xor	 edi, edi
  00061	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  00064	89 04 0b	 mov	 DWORD PTR [ebx+ecx], eax
  00067	eb 07 8d a4 24
	00 00 00 00	 npad	 9
$LL10@init_matri:

; 50   : 				matrix[i][j][a] = (float*)_aligned_malloc(k * sizeof(float), 16);

  00070	6a 10		 push	 16			; 00000010H
  00072	6a 10		 push	 16			; 00000010H
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _matrix$1$[ebp]
  0007d	83 c4 08	 add	 esp, 8
  00080	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00082	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  00085	33 f6		 xor	 esi, esi
  00087	8b 0c 19	 mov	 ecx, DWORD PTR [ecx+ebx]
  0008a	89 04 0f	 mov	 DWORD PTR [edi+ecx], eax
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR tv357[ebp]
$LL13@init_matri:

; 51   : 				for (int b = 0; b < k; b++)
; 52   : 					matrix[i][j][a][b] = is_rand?(double)(rand() / 100) / (double)(rand() / 100):0;

  00090	80 7d 0c 00	 cmp	 BYTE PTR _is_rand$[ebp], 0
  00094	74 55		 je	 SHORT $LN15@init_matri
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  0009c	8b c8		 mov	 ecx, eax
  0009e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000a3	f7 e9		 imul	 ecx
  000a5	c1 fa 05	 sar	 edx, 5
  000a8	8b c2		 mov	 eax, edx
  000aa	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ad	03 c2		 add	 eax, edx
  000af	89 45 f4	 mov	 DWORD PTR tv382[ebp], eax
  000b2	db 45 f4	 fild	 DWORD PTR tv382[ebp]
  000b5	dd 5d f0	 fstp	 QWORD PTR tv381[ebp]
  000b8	dd 45 f0	 fld	 QWORD PTR tv381[ebp]
  000bb	dd 5d e8	 fstp	 QWORD PTR tv361[ebp]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  000c4	8b c8		 mov	 ecx, eax
  000c6	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000cb	f7 e9		 imul	 ecx
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR tv357[ebp]
  000d0	c1 fa 05	 sar	 edx, 5
  000d3	8b c2		 mov	 eax, edx
  000d5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000d8	03 c2		 add	 eax, edx
  000da	89 45 f4	 mov	 DWORD PTR tv373[ebp], eax
  000dd	db 45 f4	 fild	 DWORD PTR tv373[ebp]
  000e0	dd 5d f0	 fstp	 QWORD PTR tv372[ebp]
  000e3	dd 45 f0	 fld	 QWORD PTR tv372[ebp]
  000e6	dc 7d e8	 fdivr	 QWORD PTR tv361[ebp]
  000e9	eb 02		 jmp	 SHORT $LN16@init_matri
$LN15@init_matri:
  000eb	d9 ee		 fldz
$LN16@init_matri:
  000ed	8b 45 f8	 mov	 eax, DWORD PTR _matrix$1$[ebp]
  000f0	d9 5d f4	 fstp	 DWORD PTR tv367[ebp]
  000f3	d9 45 f4	 fld	 DWORD PTR tv367[ebp]
  000f6	8b 00		 mov	 eax, DWORD PTR [eax]
  000f8	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  000fb	8b 04 18	 mov	 eax, DWORD PTR [eax+ebx]
  000fe	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00101	d9 1c 06	 fstp	 DWORD PTR [esi+eax]
  00104	83 c6 04	 add	 esi, 4
  00107	83 fe 10	 cmp	 esi, 16			; 00000010H
  0010a	7c 84		 jl	 SHORT $LL13@init_matri

; 49   : 			for (int a = 0; a < k; a++) {

  0010c	8b 75 fc	 mov	 esi, DWORD PTR tv357[ebp]
  0010f	83 c7 04	 add	 edi, 4
  00112	83 ff 10	 cmp	 edi, 16			; 00000010H
  00115	0f 8c 55 ff ff
	ff		 jl	 $LL10@init_matri

; 47   : 		for (int j = 0; j < n; j++) {

  0011b	8b 7d f8	 mov	 edi, DWORD PTR _matrix$1$[ebp]
  0011e	83 c3 04	 add	 ebx, 4
  00121	81 fb 00 02 00
	00		 cmp	 ebx, 512		; 00000200H
  00127	0f 8c 23 ff ff
	ff		 jl	 $LL7@init_matri

; 45   : 	for (int i = 0; i < n; i++) {

  0012d	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp___aligned_malloc
  00133	83 c6 04	 add	 esi, 4
  00136	89 75 fc	 mov	 DWORD PTR tv357[ebp], esi
  00139	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  0013f	0f 8c f1 fe ff
	ff		 jl	 $LL4@init_matri

; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : }

  00145	5f		 pop	 edi
  00146	5e		 pop	 esi
  00147	5b		 pop	 ebx
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	c3		 ret	 0
?init_matrix@@YAXAAPAPAPAPAMHH_N@Z ENDP			; init_matrix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
;	COMDAT _main
_TEXT	SEGMENT
tv2453 = -84						; size = 4
tv2448 = -84						; size = 4
tv2434 = -84						; size = 4
tv2452 = -80						; size = 4
tv2443 = -80						; size = 4
tv2461 = -76						; size = 4
_matrix$1$ = -76					; size = 4
tv2619 = -72						; size = 4
tv2610 = -72						; size = 4
tv2604 = -72						; size = 4
tv2442 = -72						; size = 4
tv2446 = -68						; size = 4
_i$1$ = -68						; size = 4
tv2444 = -64						; size = 4
tv2435 = -64						; size = 4
tv2445 = -60						; size = 4
tv2437 = -60						; size = 4
tv2618 = -56						; size = 8
tv2609 = -56						; size = 8
_start$2$ = -56						; size = 4
_start$1$ = -56						; size = 4
tv2460 = -48						; size = 4
tv2447 = -44						; size = 4
tv2462 = -40						; size = 4
tv2440 = -36						; size = 4
tv2416 = -32						; size = 4
tv2421 = -28						; size = 4
tv2459 = -24						; size = 8
tv2441 = -24						; size = 4
_matrix$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_main	PROC						; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 58	 sub	 esp, 88			; 00000058H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 54	 mov	 DWORD PTR __$ArrayPad$[esp+88], eax
  00014	56		 push	 esi
  00015	57		 push	 edi

; 60   : 	float ****matrix[3];
; 61   : 	for (int i = 0; i < 3; i++)

  00016	33 ff		 xor	 edi, edi
  00018	89 7c 24 1c	 mov	 DWORD PTR _i$1$[esp+96], edi
  0001c	8d 64 24 00	 npad	 4
$LL4@main:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  00020	6a 00		 push	 0
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00028	83 c4 04	 add	 esp, 4
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 43   : 	srand(time(0));

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand
  00032	83 c4 04	 add	 esp, 4

; 44   : 	matrix = (float****)_aligned_malloc(n * sizeof(float***), 16);

  00035	6a 10		 push	 16			; 00000010H
  00037	68 00 02 00 00	 push	 512			; 00000200H
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  00042	8b f0		 mov	 esi, eax
  00044	83 c4 08	 add	 esp, 8
  00047	89 74 bc 50	 mov	 DWORD PTR _matrix$[esp+edi*4+96], esi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  0004b	33 ff		 xor	 edi, edi
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 44   : 	matrix = (float****)_aligned_malloc(n * sizeof(float***), 16);

  0004d	89 74 24 14	 mov	 DWORD PTR tv2461[esp+96], esi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  00051	89 7c 24 10	 mov	 DWORD PTR tv2452[esp+96], edi
  00055	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL9@main:
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 46   : 		matrix[i] = (float***)_aligned_malloc(n * sizeof(float**), 16);

  00060	6a 10		 push	 16			; 00000010H
  00062	68 00 02 00 00	 push	 512			; 00000200H
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0006d	83 c4 08	 add	 esp, 8
  00070	89 04 37	 mov	 DWORD PTR [edi+esi], eax
  00073	33 f6		 xor	 esi, esi
  00075	89 74 24 0c	 mov	 DWORD PTR tv2453[esp+96], esi
  00079	8d a4 24 00 00
	00 00		 npad	 7
$LL12@main:

; 48   : 			matrix[i][j] = (float**)_aligned_malloc(k * sizeof(float*), 16);

  00080	6a 10		 push	 16			; 00000010H
  00082	6a 10		 push	 16			; 00000010H
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0008a	8b 4c 24 1c	 mov	 ecx, DWORD PTR tv2461[esp+104]
  0008e	83 c4 08	 add	 esp, 8
  00091	8b 0c 0f	 mov	 ecx, DWORD PTR [edi+ecx]
  00094	33 ff		 xor	 edi, edi
  00096	89 04 0e	 mov	 DWORD PTR [esi+ecx], eax
  00099	8d a4 24 00 00
	00 00		 npad	 7
$LL15@main:

; 50   : 				matrix[i][j][a] = (float*)_aligned_malloc(k * sizeof(float), 16);

  000a0	6a 10		 push	 16			; 00000010H
  000a2	6a 10		 push	 16			; 00000010H
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  000aa	8b 4c 24 18	 mov	 ecx, DWORD PTR tv2452[esp+104]
  000ae	83 c4 08	 add	 esp, 8
  000b1	8b 54 24 14	 mov	 edx, DWORD PTR tv2461[esp+96]
  000b5	8b 0c 11	 mov	 ecx, DWORD PTR [ecx+edx]
  000b8	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  000bb	33 f6		 xor	 esi, esi
  000bd	89 04 0f	 mov	 DWORD PTR [edi+ecx], eax
  000c0	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv2453[esp+96]
$LL18@main:

; 62   : 		init_matrix(matrix[i], N, K, i != 2);

  000c4	83 7c 24 1c 02	 cmp	 DWORD PTR _i$1$[esp+96], 2

; 52   : 					matrix[i][j][a][b] = is_rand?(double)(rand() / 100) / (double)(rand() / 100):0;

  000c9	74 64		 je	 SHORT $LN20@main
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  000d1	8b c8		 mov	 ecx, eax
  000d3	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000d8	f7 e9		 imul	 ecx
  000da	c1 fa 05	 sar	 edx, 5
  000dd	8b c2		 mov	 eax, edx
  000df	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000e2	03 c2		 add	 eax, edx
  000e4	89 44 24 18	 mov	 DWORD PTR tv2619[esp+96], eax
  000e8	db 44 24 18	 fild	 DWORD PTR tv2619[esp+96]
  000ec	dd 5c 24 28	 fstp	 QWORD PTR tv2618[esp+96]
  000f0	dd 44 24 28	 fld	 QWORD PTR tv2618[esp+96]
  000f4	dd 5c 24 48	 fstp	 QWORD PTR tv2459[esp+96]
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  000fe	8b c8		 mov	 ecx, eax
  00100	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00105	f7 e9		 imul	 ecx
  00107	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv2453[esp+96]
  0010b	c1 fa 05	 sar	 edx, 5
  0010e	8b c2		 mov	 eax, edx
  00110	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00113	03 c2		 add	 eax, edx
  00115	8b 54 24 14	 mov	 edx, DWORD PTR tv2461[esp+96]
  00119	89 44 24 18	 mov	 DWORD PTR tv2610[esp+96], eax
  0011d	db 44 24 18	 fild	 DWORD PTR tv2610[esp+96]
  00121	dd 5c 24 28	 fstp	 QWORD PTR tv2609[esp+96]
  00125	dd 44 24 28	 fld	 QWORD PTR tv2609[esp+96]
  00129	dc 7c 24 48	 fdivr	 QWORD PTR tv2459[esp+96]
  0012d	eb 02		 jmp	 SHORT $LN21@main
$LN20@main:
  0012f	d9 ee		 fldz
$LN21@main:
  00131	8b 44 24 10	 mov	 eax, DWORD PTR tv2452[esp+96]
  00135	d9 5c 24 18	 fstp	 DWORD PTR tv2604[esp+96]
  00139	d9 44 24 18	 fld	 DWORD PTR tv2604[esp+96]
  0013d	8b 04 10	 mov	 eax, DWORD PTR [eax+edx]
  00140	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  00143	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00146	d9 1c 06	 fstp	 DWORD PTR [esi+eax]
  00149	83 c6 04	 add	 esi, 4
  0014c	83 fe 10	 cmp	 esi, 16			; 00000010H
  0014f	0f 8c 6f ff ff
	ff		 jl	 $LL18@main

; 49   : 			for (int a = 0; a < k; a++) {

  00155	8b 74 24 0c	 mov	 esi, DWORD PTR tv2453[esp+96]
  00159	83 c7 04	 add	 edi, 4
  0015c	83 ff 10	 cmp	 edi, 16			; 00000010H
  0015f	0f 8c 3b ff ff
	ff		 jl	 $LL15@main

; 47   : 		for (int j = 0; j < n; j++) {

  00165	8b 7c 24 10	 mov	 edi, DWORD PTR tv2452[esp+96]
  00169	83 c6 04	 add	 esi, 4
  0016c	89 74 24 0c	 mov	 DWORD PTR tv2453[esp+96], esi
  00170	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  00176	0f 8c 04 ff ff
	ff		 jl	 $LL12@main

; 45   : 	for (int i = 0; i < n; i++) {

  0017c	8b 74 24 14	 mov	 esi, DWORD PTR tv2461[esp+96]
  00180	83 c7 04	 add	 edi, 4
  00183	89 7c 24 10	 mov	 DWORD PTR tv2452[esp+96], edi
  00187	81 ff 00 02 00
	00		 cmp	 edi, 512		; 00000200H
  0018d	0f 8c cd fe ff
	ff		 jl	 $LL9@main

; 60   : 	float ****matrix[3];
; 61   : 	for (int i = 0; i < 3; i++)

  00193	8b 7c 24 1c	 mov	 edi, DWORD PTR _i$1$[esp+96]
  00197	47		 inc	 edi
  00198	89 7c 24 1c	 mov	 DWORD PTR _i$1$[esp+96], edi
  0019c	83 ff 03	 cmp	 edi, 3
  0019f	0f 8c 7b fe ff
	ff		 jl	 $LL4@main

; 63   : 	DWORD start = GetTickCount64();

  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount64@0
  001ab	8b 4c 24 50	 mov	 ecx, DWORD PTR _matrix$[esp+96]
  001af	89 44 24 28	 mov	 DWORD PTR _start$1$[esp+96], eax
  001b3	8b 44 24 58	 mov	 eax, DWORD PTR _matrix$[esp+104]
  001b7	8b d0		 mov	 edx, eax
  001b9	2b c8		 sub	 ecx, eax
  001bb	89 44 24 14	 mov	 DWORD PTR _matrix$1$[esp+96], eax
  001bf	89 54 24 20	 mov	 DWORD PTR tv2444[esp+96], edx
  001c3	89 4c 24 18	 mov	 DWORD PTR tv2442[esp+96], ecx
  001c7	c7 44 24 24 80
	00 00 00	 mov	 DWORD PTR tv2445[esp+96], 128 ; 00000080H
  001cf	90		 npad	 1
$LL27@main:
  001d0	8b 0c 11	 mov	 ecx, DWORD PTR [ecx+edx]
  001d3	8b 44 24 54	 mov	 eax, DWORD PTR _matrix$[esp+100]
  001d7	8b 32		 mov	 esi, DWORD PTR [edx]
  001d9	2b c1		 sub	 eax, ecx

; 17   : 		for (int j = 0; j < N; j++)

  001db	33 d2		 xor	 edx, edx
  001dd	89 4c 24 48	 mov	 DWORD PTR tv2441[esp+96], ecx
  001e1	89 74 24 10	 mov	 DWORD PTR tv2443[esp+96], esi
  001e5	89 44 24 3c	 mov	 DWORD PTR tv2440[esp+96], eax
  001e9	89 54 24 1c	 mov	 DWORD PTR tv2446[esp+96], edx
  001ed	8d 49 00	 npad	 3
$LL30@main:

; 18   : 			for (int k = 0; k < N; k++)

  001f0	89 4c 24 34	 mov	 DWORD PTR tv2447[esp+96], ecx
  001f4	c7 44 24 38 80
	00 00 00	 mov	 DWORD PTR tv2462[esp+96], 128 ; 00000080H
  001fc	8d 64 24 00	 npad	 4
$LL33@main:

; 19   : 				for (int a = 0; a < K; a++)

  00200	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00203	8b 34 16	 mov	 esi, DWORD PTR [esi+edx]
  00206	89 74 24 0c	 mov	 DWORD PTR tv2448[esp+96], esi
  0020a	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR tv2460[esp+96], 4
  00212	8b 3c 02	 mov	 edi, DWORD PTR [edx+eax]
  00215	8b 01		 mov	 eax, DWORD PTR [ecx]
  00217	8b 4c 24 10	 mov	 ecx, DWORD PTR tv2443[esp+96]
  0021b	89 7c 24 44	 mov	 DWORD PTR tv2421[esp+96], edi
  0021f	2b 04 11	 sub	 eax, DWORD PTR [ecx+edx]
  00222	89 44 24 40	 mov	 DWORD PTR tv2416[esp+96], eax
$LL36@main:
  00226	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]

; 20   : 					for (int c = 0; c < K; c++)

  00229	2b f9		 sub	 edi, ecx

; 21   : 						for (int b = 0; b < K; b++)
; 22   : 							res[i][j][a][b] += left[i][k][a][c] * right[k][j][c][b];

  0022b	8b 16		 mov	 edx, DWORD PTR [esi]
  0022d	be 04 00 00 00	 mov	 esi, 4
$LL39@main:
  00232	8b 04 39	 mov	 eax, DWORD PTR [ecx+edi]
  00235	d9 00		 fld	 DWORD PTR [eax]
  00237	d8 09		 fmul	 DWORD PTR [ecx]
  00239	d8 02		 fadd	 DWORD PTR [edx]
  0023b	d9 1a		 fstp	 DWORD PTR [edx]
  0023d	d9 40 04	 fld	 DWORD PTR [eax+4]
  00240	d8 09		 fmul	 DWORD PTR [ecx]
  00242	d8 42 04	 fadd	 DWORD PTR [edx+4]
  00245	d9 5a 04	 fstp	 DWORD PTR [edx+4]
  00248	d9 40 08	 fld	 DWORD PTR [eax+8]
  0024b	d8 09		 fmul	 DWORD PTR [ecx]
  0024d	d8 42 08	 fadd	 DWORD PTR [edx+8]
  00250	d9 5a 08	 fstp	 DWORD PTR [edx+8]
  00253	d9 40 0c	 fld	 DWORD PTR [eax+12]
  00256	d8 09		 fmul	 DWORD PTR [ecx]
  00258	83 c1 04	 add	 ecx, 4
  0025b	d8 42 0c	 fadd	 DWORD PTR [edx+12]
  0025e	d9 5a 0c	 fstp	 DWORD PTR [edx+12]
  00261	83 ee 01	 sub	 esi, 1
  00264	75 cc		 jne	 SHORT $LL39@main

; 19   : 				for (int a = 0; a < K; a++)

  00266	8b 74 24 0c	 mov	 esi, DWORD PTR tv2448[esp+96]
  0026a	8b 44 24 40	 mov	 eax, DWORD PTR tv2416[esp+96]
  0026e	83 c6 04	 add	 esi, 4
  00271	83 6c 24 30 01	 sub	 DWORD PTR tv2460[esp+96], 1
  00276	8b 7c 24 44	 mov	 edi, DWORD PTR tv2421[esp+96]
  0027a	89 74 24 0c	 mov	 DWORD PTR tv2448[esp+96], esi
  0027e	75 a6		 jne	 SHORT $LL36@main

; 18   : 			for (int k = 0; k < N; k++)

  00280	8b 4c 24 34	 mov	 ecx, DWORD PTR tv2447[esp+96]
  00284	8b 54 24 1c	 mov	 edx, DWORD PTR tv2446[esp+96]
  00288	83 c1 04	 add	 ecx, 4
  0028b	83 6c 24 38 01	 sub	 DWORD PTR tv2462[esp+96], 1
  00290	8b 44 24 3c	 mov	 eax, DWORD PTR tv2440[esp+96]
  00294	8b 74 24 10	 mov	 esi, DWORD PTR tv2443[esp+96]
  00298	89 4c 24 34	 mov	 DWORD PTR tv2447[esp+96], ecx
  0029c	0f 85 5e ff ff
	ff		 jne	 $LL33@main

; 17   : 		for (int j = 0; j < N; j++)

  002a2	8b 4c 24 48	 mov	 ecx, DWORD PTR tv2441[esp+96]
  002a6	83 c2 04	 add	 edx, 4
  002a9	89 54 24 1c	 mov	 DWORD PTR tv2446[esp+96], edx
  002ad	81 fa 00 02 00
	00		 cmp	 edx, 512		; 00000200H
  002b3	0f 8c 37 ff ff
	ff		 jl	 $LL30@main

; 16   : 	for (int i = 0; i < N; i++)

  002b9	8b 54 24 20	 mov	 edx, DWORD PTR tv2444[esp+96]
  002bd	8b 4c 24 18	 mov	 ecx, DWORD PTR tv2442[esp+96]
  002c1	83 c2 04	 add	 edx, 4
  002c4	83 6c 24 24 01	 sub	 DWORD PTR tv2445[esp+96], 1
  002c9	89 54 24 20	 mov	 DWORD PTR tv2444[esp+96], edx
  002cd	0f 85 fd fe ff
	ff		 jne	 $LL27@main

; 64   : 	auto_vectorize(matrix[0], matrix[1], matrix[2]);
; 65   : 	DWORD duration = GetTickCount64() - start;

  002d3	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount64@0
  002d9	ff d6		 call	 esi
  002db	2b 44 24 28	 sub	 eax, DWORD PTR _start$1$[esp+96]

; 66   : 	cout << "auto_vec: " << duration << " ticks" << endl;

  002df	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0L@HNBJPKEP@auto_vec?3?5@
  002e4	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002e9	50		 push	 eax
  002ea	51		 push	 ecx
  002eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002f1	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002f6	83 c4 04	 add	 esp, 4
  002f9	8b c8		 mov	 ecx, eax
  002fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
  00301	51		 push	 ecx
  00302	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06MALMBFOP@?5ticks@
  00307	8b c8		 mov	 ecx, eax
  00309	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0030e	83 c4 04	 add	 esp, 4
  00311	8b c8		 mov	 ecx, eax
  00313	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 67   : 	start = GetTickCount64();

  00319	ff d6		 call	 esi
  0031b	89 44 24 28	 mov	 DWORD PTR _start$2$[esp+96], eax
  0031f	c7 44 24 20 80
	00 00 00	 mov	 DWORD PTR tv2435[esp+96], 128 ; 00000080H
$LL47@main:

; 27   : 		for (int j = 0; j < N; j++)

  00327	33 c9		 xor	 ecx, ecx
  00329	89 4c 24 0c	 mov	 DWORD PTR tv2434[esp+96], ecx
  0032d	8d 49 00	 npad	 3
$LL50@main:

; 28   : 			for (int k = 0; k < N; k++)

  00330	33 ff		 xor	 edi, edi
  00332	89 7c 24 24	 mov	 DWORD PTR tv2437[esp+96], edi
$LL53@main:

; 29   : 				for (int a = 0; a < K; a++)

  00336	33 f6		 xor	 esi, esi
  00338	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL56@main:

; 30   : 					for (int c = 0; c < K; c++) {

  00340	33 d2		 xor	 edx, edx
$LL59@main:

; 31   : 						__m128 const_value = _mm_set1_ps(left[i][k][a][c]);

  00342	8b 4c 24 18	 mov	 ecx, DWORD PTR tv2442[esp+96]
  00346	8b 44 24 14	 mov	 eax, DWORD PTR _matrix$1$[esp+96]
  0034a	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]

; 32   : 						for (int b = 0; b < K; b += 4) {
; 33   : 							__m128 string_value = _mm_load_ps(&right[k][j][c][b]);
; 34   : 							__m128 res_value = _mm_load_ps(&res[i][j][a][b]);
; 35   : 							res_value = _mm_add_ps(res_value, _mm_mul_ps(string_value, const_value));
; 36   : 							_mm_store_ps(&res[i][j][a][b], res_value);

  0034d	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv2434[esp+96]
  00351	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00354	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  00357	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  0035c	8b 44 24 14	 mov	 eax, DWORD PTR _matrix$1$[esp+96]
  00360	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00364	8b 00		 mov	 eax, DWORD PTR [eax]
  00366	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00369	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  0036c	8b 44 24 54	 mov	 eax, DWORD PTR _matrix$[esp+100]
  00370	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  00373	8b 7c 24 0c	 mov	 edi, DWORD PTR tv2434[esp+96]
  00377	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  0037a	8b 7c 24 24	 mov	 edi, DWORD PTR tv2437[esp+96]
  0037e	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00381	83 c2 04	 add	 edx, 4
  00384	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  00387	0f 59 c8	 mulps	 xmm1, xmm0
  0038a	0f 58 09	 addps	 xmm1, XMMWORD PTR [ecx]
  0038d	0f 11 09	 movups	 XMMWORD PTR [ecx], xmm1
  00390	83 fa 10	 cmp	 edx, 16			; 00000010H
  00393	7c ad		 jl	 SHORT $LL59@main

; 29   : 				for (int a = 0; a < K; a++)

  00395	83 c6 04	 add	 esi, 4
  00398	83 fe 10	 cmp	 esi, 16			; 00000010H
  0039b	7c a3		 jl	 SHORT $LL56@main

; 28   : 			for (int k = 0; k < N; k++)

  0039d	83 c7 04	 add	 edi, 4
  003a0	89 7c 24 24	 mov	 DWORD PTR tv2437[esp+96], edi
  003a4	81 ff 00 02 00
	00		 cmp	 edi, 512		; 00000200H
  003aa	7c 8a		 jl	 SHORT $LL53@main

; 27   : 		for (int j = 0; j < N; j++)

  003ac	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv2434[esp+96]
  003b0	83 c1 04	 add	 ecx, 4
  003b3	89 4c 24 0c	 mov	 DWORD PTR tv2434[esp+96], ecx
  003b7	81 f9 00 02 00
	00		 cmp	 ecx, 512		; 00000200H
  003bd	0f 8c 6d ff ff
	ff		 jl	 $LL50@main

; 23   : }
; 24   : void my_vectorize(float**** left, float**** right, float**** res)
; 25   : {
; 26   : 	for (int i = 0; i < N; i++)

  003c3	83 44 24 14 04	 add	 DWORD PTR _matrix$1$[esp+96], 4
  003c8	83 6c 24 20 01	 sub	 DWORD PTR tv2435[esp+96], 1
  003cd	0f 85 54 ff ff
	ff		 jne	 $LL47@main

; 68   : 	my_vectorize(matrix[0], matrix[1], matrix[2]);
; 69   : 	duration = GetTickCount64() - start;

  003d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount64@0
  003d9	2b 44 24 28	 sub	 eax, DWORD PTR _start$2$[esp+96]

; 70   : 	cout << "my_vec: " << duration << " ticks" << endl;

  003dd	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08MLBKJEKP@my_vec?3?5@
  003e2	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  003e7	50		 push	 eax
  003e8	51		 push	 ecx
  003e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  003ef	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003f4	83 c4 04	 add	 esp, 4
  003f7	8b c8		 mov	 ecx, eax
  003f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
  003ff	51		 push	 ecx
  00400	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06MALMBFOP@?5ticks@
  00405	8b c8		 mov	 ecx, eax
  00407	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0040c	83 c4 04	 add	 esp, 4
  0040f	8b c8		 mov	 ecx, eax
  00411	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 71   : 	system("pause > NUL");

  00417	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NADFNJG@pause?5?$DO?5NUL@
  0041c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__system

; 72   : 	return 0;
; 73   : }

  00422	8b 4c 24 60	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+100]
  00426	83 c4 04	 add	 esp, 4
  00429	33 c0		 xor	 eax, eax
  0042b	5f		 pop	 edi
  0042c	5e		 pop	 esi
  0042d	33 cc		 xor	 ecx, esp
  0042f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00434	8b e5		 mov	 esp, ebp
  00436	5d		 pop	 ebp
  00437	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 131  :             return _Ok;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 132  :         }

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 115  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 116  : #if _HAS_EXCEPTIONS
; 117  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  0002b	84 c0		 test	 al, al
  0002d	75 08		 jne	 SHORT $LN2@sentry

; 118  :                 this->_Myostr._Osfx();

  0002f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  0003e	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 78   :             if (_Rdbuf) {

  00049	85 c9		 test	 ecx, ecx
  0004b	74 05		 je	 SHORT $LN5@sentry

; 79   :                 _Rdbuf->_Unlock();

  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:

; 119  :             }
; 120  : #else // _HAS_EXCEPTIONS
; 121  :             this->_Myostr._Osfx();
; 122  : #endif // _HAS_EXCEPTIONS
; 123  :         }

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	8b 7d 08	 mov	 edi, DWORD PTR __Ostr$[ebp]

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  0002d	89 3e		 mov	 DWORD PTR [esi], edi

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

  0002f	8b 17		 mov	 edx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  00031	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00034	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 71   :             if (_Rdbuf) {

  00038	85 c9		 test	 ecx, ecx
  0003a	74 07		 je	 SHORT $LN8@sentry

; 72   :                 _Rdbuf->_Lock();

  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
  00041	8b 17		 mov	 edx, DWORD PTR [edi]
$LN8@sentry:

; 91   :             : _Sentry_base(_Ostr) { // construct locking and testing stream

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 276  :         return _Mystate;

  0004a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 295  :         return rdstate() == ios_base::goodbit;

  0004d	83 7c 38 0c 00	 cmp	 DWORD PTR [eax+edi+12], 0

; 276  :         return _Mystate;

  00052	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 92   :             if (!_Ostr.good()) {

  00055	74 04		 je	 SHORT $LN2@sentry

; 93   :                 _Ok = false;

  00057	32 c0		 xor	 al, al

; 94   :                 return;

  00059	eb 22		 jmp	 SHORT $LN23@sentry
$LN2@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 66   :         return _Tiestr;

  0005b	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

  0005e	85 c9		 test	 ecx, ecx
  00060	74 19		 je	 SHORT $LN4@sentry
  00062	3b cf		 cmp	 ecx, edi
  00064	74 15		 je	 SHORT $LN4@sentry

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  : 
; 104  :             _Tied->flush();

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  0006c	8b 07		 mov	 eax, DWORD PTR [edi]
  0006e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00071	83 7c 38 0c 00	 cmp	 DWORD PTR [eax+edi+12], 0
  00076	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  00079	eb 02		 jmp	 SHORT $LN23@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

  0007b	b0 01		 mov	 al, 1
$LN23@sentry:

; 106  :         }

  0007d	88 46 04	 mov	 BYTE PTR [esi+4], al
  00080	8b c6		 mov	 eax, esi
  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 411  :         return static_cast<int_type>(EOF);

  00000	83 c8 ff	 or	 eax, -1

; 412  :     }

  00003	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 402  :         // test for metacharacter equality
; 403  :         return _Left == _Right;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 02		 cmp	 eax, DWORD PTR [edx]
  00004	0f 94 c0	 sete	 al

; 404  :     }

  00007	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT
; __First$ = ecx

; 311  :         // find length of null-terminated string
; 312  : #if _HAS_CXX17
; 313  : #if _HAS_CHAR8_T
; 314  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 315  : #if _HAS_U8_INTRINSICS
; 316  :             return __builtin_u8strlen(_First);
; 317  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 318  :             return _Char_traits<_Elem, _Int_type>::length(_First);
; 319  : #endif // _HAS_U8_INTRINSICS
; 320  :         } else
; 321  : #endif // _HAS_CHAR8_T
; 322  :         {
; 323  :             return __builtin_strlen(_First);
; 324  :         }
; 325  : #else // _HAS_CXX17
; 326  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00000	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL3@length:
  00003	8a 01		 mov	 al, BYTE PTR [ecx]
  00005	41		 inc	 ecx
  00006	84 c0		 test	 al, al
  00008	75 f9		 jne	 SHORT $LL3@length
  0000a	2b ca		 sub	 ecx, edx
  0000c	8b c1		 mov	 eax, ecx

; 327  : #endif // _HAS_CXX17
; 328  :     }

  0000e	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 78   :             if (_Rdbuf) {

  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 71   :             if (_Rdbuf) {

  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN6@Sentry_bas

; 72   :                 _Rdbuf->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN6@Sentry_bas:

; 73   :             }
; 74   :         }

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -44						; size = 8
__State$ = -36						; size = 4
__Val$1$ = -32						; size = 4
$T15 = -32						; size = 1
tv669 = -28						; size = 4
$T9 = -28						; size = 1
__Ostr$ = -24						; size = 4
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 738  :     const char* _Val) { // insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b c2		 mov	 eax, edx
  0002d	89 45 e0	 mov	 DWORD PTR __Val$1$[ebp], eax
  00030	8b d9		 mov	 ebx, ecx
  00032	89 5d e8	 mov	 DWORD PTR __Ostr$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring

; 326  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00035	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 742  :     ios_base::iostate _State = ios_base::goodbit;

  00037	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring

; 326  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0003e	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL93@operator:
  00041	8a 01		 mov	 al, BYTE PTR [ecx]
  00043	41		 inc	 ecx
  00044	84 c0		 test	 al, al
  00046	75 f9		 jne	 SHORT $LL93@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 744  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00048	8b 13		 mov	 edx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring

; 326  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0004a	2b ce		 sub	 ecx, esi
  0004c	89 4d ec	 mov	 DWORD PTR __Count$2$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 363  :         return _Wide;

  0004f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00052	03 c3		 add	 eax, ebx
  00054	89 45 e4	 mov	 DWORD PTR tv669[ebp], eax
  00057	8b 78 24	 mov	 edi, DWORD PTR [eax+36]
  0005a	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 744  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  0005d	85 ff		 test	 edi, edi
  0005f	7c 17		 jl	 SHORT $LN17@operator
  00061	7f 0e		 jg	 SHORT $LN95@operator
  00063	85 f6		 test	 esi, esi
  00065	74 11		 je	 SHORT $LN17@operator
  00067	85 ff		 test	 edi, edi
  00069	7c 0d		 jl	 SHORT $LN17@operator
  0006b	7f 04		 jg	 SHORT $LN95@operator
  0006d	3b f1		 cmp	 esi, ecx
  0006f	76 07		 jbe	 SHORT $LN17@operator
$LN95@operator:
  00071	2b f1		 sub	 esi, ecx
  00073	83 df 00	 sbb	 edi, 0
  00076	eb 04		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00078	33 f6		 xor	 esi, esi
  0007a	33 ff		 xor	 edi, edi
$LN18@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  0007c	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0007f	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00081	89 5d d4	 mov	 DWORD PTR __Ok$[ebp], ebx

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();
; 71   :             if (_Rdbuf) {

  00084	85 c0		 test	 eax, eax
  00086	74 0f		 je	 SHORT $LN39@operator

; 72   :                 _Rdbuf->_Lock();

  00088	8b 4d e4	 mov	 ecx, DWORD PTR tv669[ebp]
  0008b	8b 00		 mov	 eax, DWORD PTR [eax]
  0008d	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  00090	ff 50 04	 call	 DWORD PTR [eax+4]
  00093	8b 13		 mov	 edx, DWORD PTR [ebx]
  00095	8b ca		 mov	 ecx, edx
$LN39@operator:

; 91   :             : _Sentry_base(_Ostr) { // construct locking and testing stream

  00097	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 276  :         return _Mystate;

  0009e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a1	03 c3		 add	 eax, ebx

; 295  :         return rdstate() == ios_base::goodbit;

  000a3	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 92   :             if (!_Ostr.good()) {

  000a7	74 04		 je	 SHORT $LN33@operator

; 93   :                 _Ok = false;

  000a9	32 c0		 xor	 al, al

; 94   :                 return;

  000ab	eb 26		 jmp	 SHORT $LN108@operator
$LN33@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 66   :         return _Tiestr;

  000ad	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

  000b0	85 c0		 test	 eax, eax
  000b2	74 1d		 je	 SHORT $LN35@operator
  000b4	3b c3		 cmp	 eax, ebx
  000b6	74 19		 je	 SHORT $LN35@operator

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  : 
; 104  :             _Tied->flush();

  000b8	8b c8		 mov	 ecx, eax
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000c0	8b 13		 mov	 edx, DWORD PTR [ebx]
  000c2	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 276  :         return _Mystate;

  000c4	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 295  :         return rdstate() == ios_base::goodbit;

  000c7	83 7c 18 0c 00	 cmp	 DWORD PTR [eax+ebx+12], 0
  000cc	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000cf	eb 02		 jmp	 SHORT $LN108@operator
$LN35@operator:

; 99   :                 _Ok = true;

  000d1	b0 01		 mov	 al, 1
$LN108@operator:

; 745  :     const typename _Myos::sentry _Ok(_Ostr);

  000d3	88 45 d8	 mov	 BYTE PTR __Ok$[ebp+4], al
  000d6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 746  : 
; 747  :     if (!_Ok) {

  000dd	84 c0		 test	 al, al
  000df	75 0a		 jne	 SHORT $LN8@operator

; 748  :         _State |= ios_base::badbit;

  000e1	b9 04 00 00 00	 mov	 ecx, 4

; 749  :     } else { // state okay, insert

  000e6	e9 e1 00 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 750  :         _TRY_IO_BEGIN

  000eb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 326  :         return _Fmtfl;

  000ef	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f2	8b 44 18 14	 mov	 eax, DWORD PTR [eax+ebx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 751  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000f6	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000fb	83 f8 40	 cmp	 eax, 64			; 00000040H
  000fe	74 37		 je	 SHORT $LN89@operator
$LL4@operator:

; 752  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00100	85 ff		 test	 edi, edi
  00102	7c 31		 jl	 SHORT $LN3@operator
  00104	7f 04		 jg	 SHORT $LN96@operator
  00106	85 f6		 test	 esi, esi
  00108	74 2b		 je	 SHORT $LN3@operator
$LN96@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 97   :         return _Fillch;

  0010a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0010c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0010f	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 753  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00113	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 97   :         return _Fillch;

  00117	88 45 e4	 mov	 BYTE PTR $T9[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 753  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0011a	ff 75 e4	 push	 DWORD PTR $T9[ebp]
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00123	83 f8 ff	 cmp	 eax, -1
  00126	75 05		 jne	 SHORT $LN2@operator

; 754  :                     _State |= ios_base::badbit; // insertion failed, quit

  00128	8d 48 05	 lea	 ecx, DWORD PTR [eax+5]

; 755  :                     break;

  0012b	eb 61		 jmp	 SHORT $LN6@operator
$LN2@operator:

; 752  :             for (; 0 < _Pad; --_Pad) { // pad on left

  0012d	83 c6 ff	 add	 esi, -1
  00130	83 d7 ff	 adc	 edi, -1
  00133	eb cb		 jmp	 SHORT $LL4@operator
$LN3@operator:

; 760  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00135	8b 0b		 mov	 ecx, DWORD PTR [ebx]
$LN89@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  00137	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 760  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0013a	6a 00		 push	 0
  0013c	ff 75 ec	 push	 DWORD PTR __Count$2$[ebp]
  0013f	ff 75 e0	 push	 DWORD PTR __Val$1$[ebp]
  00142	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  0014c	3b 45 ec	 cmp	 eax, DWORD PTR __Count$2$[ebp]
  0014f	75 2c		 jne	 SHORT $LN97@operator
  00151	85 d2		 test	 edx, edx
  00153	75 28		 jne	 SHORT $LN97@operator
$LL99@operator:

; 761  :             _State |= ios_base::badbit;
; 762  :         }
; 763  : 
; 764  :         if (_State == ios_base::goodbit) {
; 765  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00155	85 ff		 test	 edi, edi
  00157	7c 33		 jl	 SHORT $LN103@operator
  00159	7f 04		 jg	 SHORT $LN98@operator
  0015b	85 f6		 test	 esi, esi
  0015d	74 2d		 je	 SHORT $LN103@operator
$LN98@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 97   :         return _Fillch;

  0015f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00161	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00164	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 766  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00168	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 97   :         return _Fillch;

  0016c	88 45 e0	 mov	 BYTE PTR $T15[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 766  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0016f	ff 75 e0	 push	 DWORD PTR $T15[ebp]
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00178	83 f8 ff	 cmp	 eax, -1
  0017b	75 07		 jne	 SHORT $LN5@operator
$LN97@operator:

; 767  :                     _State |= ios_base::badbit; // insertion failed, quit
; 768  :                     break;
; 769  :                 }
; 770  :             }
; 771  :         }
; 772  : 
; 773  :         _Ostr.width(0);

  0017d	b9 04 00 00 00	 mov	 ecx, 4
  00182	eb 0a		 jmp	 SHORT $LN6@operator
$LN5@operator:

; 761  :             _State |= ios_base::badbit;
; 762  :         }
; 763  : 
; 764  :         if (_State == ios_base::goodbit) {
; 765  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00184	83 c6 ff	 add	 esi, -1
  00187	83 d7 ff	 adc	 edi, -1
  0018a	eb c9		 jmp	 SHORT $LL99@operator
$LN103@operator:

; 767  :                     _State |= ios_base::badbit; // insertion failed, quit
; 768  :                     break;
; 769  :                 }
; 770  :             }
; 771  :         }
; 772  : 
; 773  :         _Ostr.width(0);

  0018c	33 c9		 xor	 ecx, ecx
$LN6@operator:
  0018e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00190	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  00193	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  0019b	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
  001a3	eb 20		 jmp	 SHORT $LN109@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 774  :         _CATCH_IO_(ios_base, _Ostr)

  001a5	8b 55 e8	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001a8	6a 01		 push	 1
  001aa	6a 04		 push	 4
  001ac	8b 02		 mov	 eax, DWORD PTR [edx]
  001ae	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001b1	03 ca		 add	 ecx, edx
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001b9	b8 00 00 00 00	 mov	 eax, $LN23@operator
  001be	c3		 ret	 0
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
  001bf	8b 5d e8	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  001c2	8b 4d dc	 mov	 ecx, DWORD PTR __State$[ebp]
$LN109@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 775  :     }
; 776  : 
; 777  :     _Ostr.setstate(_State);

  001c5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
  001cc	8b 03		 mov	 eax, DWORD PTR [ebx]
  001ce	6a 00		 push	 0
  001d0	51		 push	 ecx
  001d1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001d4	03 cb		 add	 ecx, ebx
  001d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 115  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  001dc	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 116  : #if _HAS_EXCEPTIONS
; 117  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

  001e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  001e9	8b 75 d4	 mov	 esi, DWORD PTR __Ok$[ebp]
  001ec	84 c0		 test	 al, al
  001ee	75 08		 jne	 SHORT $LN74@operator

; 118  :                 this->_Myostr._Osfx();

  001f0	8b ce		 mov	 ecx, esi
  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN74@operator:

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  001f8	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  001fc	8b 06		 mov	 eax, DWORD PTR [esi]
  001fe	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00201	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 78   :             if (_Rdbuf) {

  00205	85 c9		 test	 ecx, ecx
  00207	74 05		 je	 SHORT $LN100@operator

; 79   :                 _Rdbuf->_Unlock();

  00209	8b 01		 mov	 eax, DWORD PTR [ecx]
  0020b	ff 50 08	 call	 DWORD PTR [eax+8]
$LN100@operator:

; 778  :     return _Ostr;
; 779  : }

  0020e	8b c3		 mov	 eax, ebx
  00210	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00213	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0021a	59		 pop	 ecx
  0021b	5f		 pop	 edi
  0021c	5e		 pop	 esi
  0021d	5b		 pop	 ebx
  0021e	8b e5		 mov	 esp, ebp
  00220	5d		 pop	 ebp
  00221	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00008	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 950  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 951  :     _Ostr.put(_Ostr.widen('\n'));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  00007	6a 0a		 push	 10			; 0000000aH
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	03 ce		 add	 ecx, esi
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00016	0f b6 c8	 movzx	 ecx, al
  00019	51		 push	 ecx
  0001a	8b ce		 mov	 ecx, esi
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 952  :     _Ostr.flush();

  00022	8b ce		 mov	 ecx, esi
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 953  :     return _Ostr;

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi

; 954  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
END
