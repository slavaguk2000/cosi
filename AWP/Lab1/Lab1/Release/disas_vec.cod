; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	d:\univer\6 sem\awp\lab1\lab1\source.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_06MALMBFOP@?5ticks@			; `string'
PUBLIC	??_C@_0L@HNBJPKEP@auto_vec?3?5@			; `string'
PUBLIC	??_C@_08MLBKJEKP@my_vec?3?5@			; `string'
PUBLIC	??_C@_0M@NADFNJG@pause?5?$DO?5NUL@		; `string'
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp____std_terminate:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp__GetTickCount64@0:PROC
EXTRN	__imp__system:PROC
EXTRN	__imp___aligned_malloc:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp__srand:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
;	COMDAT ??_C@_0M@NADFNJG@pause?5?$DO?5NUL@
CONST	SEGMENT
??_C@_0M@NADFNJG@pause?5?$DO?5NUL@ DB 'pause > NUL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLBKJEKP@my_vec?3?5@
CONST	SEGMENT
??_C@_08MLBKJEKP@my_vec?3?5@ DB 'my_vec: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HNBJPKEP@auto_vec?3?5@
CONST	SEGMENT
??_C@_0L@HNBJPKEP@auto_vec?3?5@ DB 'auto_vec: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MALMBFOP@?5ticks@
CONST	SEGMENT
??_C@_06MALMBFOP@?5ticks@ DB ' ticks', 00H		; `string'
CONST	ENDS
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	_main
PUBLIC	?init_matrix@@YAXAAPAPAPAPAMHH_N@Z		; init_matrix
PUBLIC	?my_vectorize@@YAXPAPAPAPAM00@Z			; my_vectorize
PUBLIC	?auto_vectorize@@YAXPAPAPAPAM00@Z		; auto_vectorize
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000500000000r		; 1.061e-313
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DQ 00000000119930522r ; 2.33398e-314
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DQ 00000000019930522r ; 2.11987e-315
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DQ	00000000000000000r		; 0
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DQ 00000000619930522r ; 1.2944e-313
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DQ	00000000000000000r		; 0
	DQ	00000000100000000r		; 2.122e-314
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DQ	00000000000000001r		; 4.94066e-324
	DQ	00000000000000001r		; 4.94066e-324
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DQ 00000000200000002r ; 4.24399e-314
	DQ	00000000100000003r		; 2.122e-314
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6 DQ 00000000000000040r ; 3.16202e-322
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
;	COMDAT ?auto_vectorize@@YAXPAPAPAPAM00@Z
_TEXT	SEGMENT
_right$1$ = -52						; size = 4
_left$1$ = -48						; size = 4
tv1321 = -44						; size = 4
tv1319 = -40						; size = 4
tv1318 = -36						; size = 4
tv1317 = -32						; size = 4
tv1315 = -28						; size = 4
tv1325 = -24						; size = 4
tv1323 = -20						; size = 4
tv1327 = -16						; size = 4
tv1328 = -12						; size = 4
tv1334 = -8						; size = 4
tv1326 = -4						; size = 4
_res$ = 8						; size = 4
?auto_vectorize@@YAXPAPAPAPAM00@Z PROC			; auto_vectorize, COMDAT
; _left$ = ecx
; _right$ = edx

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 16   : 	for (int i = 0; i < N; i++)

  00006	8b 45 08	 mov	 eax, DWORD PTR _res$[ebp]
  00009	2b c8		 sub	 ecx, eax
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	89 55 cc	 mov	 DWORD PTR _right$1$[ebp], edx
  00010	89 4d d0	 mov	 DWORD PTR _left$1$[ebp], ecx
  00013	c7 45 e8 80 00
	00 00		 mov	 DWORD PTR tv1325[ebp], 128 ; 00000080H
  0001a	57		 push	 edi
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@auto_vecto:

; 17   : 		for (int j = 0; j < N; j++)

  00020	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  00023	8b 18		 mov	 ebx, DWORD PTR [eax]
  00025	8b c2		 mov	 eax, edx
  00027	2b c1		 sub	 eax, ecx
  00029	89 4d d8	 mov	 DWORD PTR tv1319[ebp], ecx
  0002c	33 d2		 xor	 edx, edx
  0002e	89 5d d4	 mov	 DWORD PTR tv1321[ebp], ebx
  00031	89 45 ec	 mov	 DWORD PTR tv1323[ebp], eax
  00034	89 55 fc	 mov	 DWORD PTR tv1326[ebp], edx
$LL7@auto_vecto:

; 18   : 			for (int k = 0; k < N; k++)

  00037	8b 3c 1a	 mov	 edi, DWORD PTR [edx+ebx]
  0003a	89 7d dc	 mov	 DWORD PTR tv1318[ebp], edi
  0003d	89 4d f4	 mov	 DWORD PTR tv1328[ebp], ecx
  00040	c7 45 f0 80 00
	00 00		 mov	 DWORD PTR tv1327[ebp], 128 ; 00000080H
  00047	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL10@auto_vecto:

; 19   : 				for (int a = 0; a < K; a++)

  00050	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00053	8b df		 mov	 ebx, edi
  00055	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR tv1334[ebp], 4
  0005c	8b 34 02	 mov	 esi, DWORD PTR [edx+eax]
  0005f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00061	2b c7		 sub	 eax, edi
  00063	89 75 e0	 mov	 DWORD PTR tv1317[ebp], esi
  00066	89 45 e4	 mov	 DWORD PTR tv1315[ebp], eax
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@auto_vecto:

; 20   : 					for (int c = 0; c < K; c++)

  00070	8b 14 03	 mov	 edx, DWORD PTR [ebx+eax]
  00073	8b fe		 mov	 edi, esi

; 21   : 						for (int b = 0; b < K; b++)
; 22   : 							res[i][j][a][b] += left[i][k][a][c] * right[k][j][c][b];

  00075	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00077	2b fa		 sub	 edi, edx
  00079	be 04 00 00 00	 mov	 esi, 4
  0007e	66 90		 npad	 2
$LL16@auto_vecto:
  00080	8b 04 3a	 mov	 eax, DWORD PTR [edx+edi]
  00083	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00087	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0008b	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  0008f	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00093	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00098	f3 0f 59 02	 mulss	 xmm0, DWORD PTR [edx]
  0009c	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  000a1	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  000a6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000ab	f3 0f 59 02	 mulss	 xmm0, DWORD PTR [edx]
  000af	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  000b4	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  000b9	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000be	f3 0f 59 02	 mulss	 xmm0, DWORD PTR [edx]
  000c2	83 c2 04	 add	 edx, 4
  000c5	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  000ca	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  000cf	83 ee 01	 sub	 esi, 1
  000d2	75 ac		 jne	 SHORT $LL16@auto_vecto

; 19   : 				for (int a = 0; a < K; a++)

  000d4	8b 45 e4	 mov	 eax, DWORD PTR tv1315[ebp]
  000d7	83 c3 04	 add	 ebx, 4
  000da	83 6d f8 01	 sub	 DWORD PTR tv1334[ebp], 1
  000de	8b 75 e0	 mov	 esi, DWORD PTR tv1317[ebp]
  000e1	75 8d		 jne	 SHORT $LL13@auto_vecto

; 18   : 			for (int k = 0; k < N; k++)

  000e3	8b 4d f4	 mov	 ecx, DWORD PTR tv1328[ebp]
  000e6	8b 55 fc	 mov	 edx, DWORD PTR tv1326[ebp]
  000e9	83 c1 04	 add	 ecx, 4
  000ec	83 6d f0 01	 sub	 DWORD PTR tv1327[ebp], 1
  000f0	8b 7d dc	 mov	 edi, DWORD PTR tv1318[ebp]
  000f3	8b 45 ec	 mov	 eax, DWORD PTR tv1323[ebp]
  000f6	89 4d f4	 mov	 DWORD PTR tv1328[ebp], ecx
  000f9	0f 85 51 ff ff
	ff		 jne	 $LL10@auto_vecto

; 17   : 		for (int j = 0; j < N; j++)

  000ff	8b 4d d8	 mov	 ecx, DWORD PTR tv1319[ebp]
  00102	83 c2 04	 add	 edx, 4
  00105	8b 5d d4	 mov	 ebx, DWORD PTR tv1321[ebp]
  00108	89 55 fc	 mov	 DWORD PTR tv1326[ebp], edx
  0010b	81 fa 00 02 00
	00		 cmp	 edx, 512		; 00000200H
  00111	0f 8c 20 ff ff
	ff		 jl	 $LL7@auto_vecto

; 16   : 	for (int i = 0; i < N; i++)

  00117	8b 45 08	 mov	 eax, DWORD PTR _res$[ebp]
  0011a	8b 4d d0	 mov	 ecx, DWORD PTR _left$1$[ebp]
  0011d	83 c0 04	 add	 eax, 4
  00120	83 6d e8 01	 sub	 DWORD PTR tv1325[ebp], 1
  00124	8b 55 cc	 mov	 edx, DWORD PTR _right$1$[ebp]
  00127	89 45 08	 mov	 DWORD PTR _res$[ebp], eax
  0012a	0f 85 f0 fe ff
	ff		 jne	 $LL4@auto_vecto

; 23   : }

  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5b		 pop	 ebx
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c3		 ret	 0
?auto_vectorize@@YAXPAPAPAPAM00@Z ENDP			; auto_vectorize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
;	COMDAT ?my_vectorize@@YAXPAPAPAPAM00@Z
_TEXT	SEGMENT
_right$1$ = -20						; size = 4
_left$1$ = -16						; size = 4
tv671 = -12						; size = 4
tv674 = -8						; size = 4
tv672 = -4						; size = 4
_res$ = 8						; size = 4
?my_vectorize@@YAXPAPAPAPAM00@Z PROC			; my_vectorize, COMDAT
; _left$ = ecx
; _right$ = edx

; 25   : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 18	 sub	 esp, 24			; 00000018H

; 26   : 	for (int i = 0; i < N; i++)

  00019	8b 43 08	 mov	 eax, DWORD PTR _res$[ebx]
  0001c	2b c8		 sub	 ecx, eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	89 55 ec	 mov	 DWORD PTR _right$1$[ebp], edx
  00023	89 4d f0	 mov	 DWORD PTR _left$1$[ebp], ecx
  00026	c7 45 f4 80 00
	00 00		 mov	 DWORD PTR tv671[ebp], 128 ; 00000080H
  0002d	0f 1f 00	 npad	 3
$LL4@my_vectori:

; 27   : 		for (int j = 0; j < N; j++)

  00030	33 c9		 xor	 ecx, ecx
  00032	89 4d fc	 mov	 DWORD PTR tv672[ebp], ecx
$LL7@my_vectori:

; 28   : 			for (int k = 0; k < N; k++)

  00035	33 ff		 xor	 edi, edi
  00037	89 7d f8	 mov	 DWORD PTR tv674[ebp], edi
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL10@my_vectori:

; 29   : 				for (int a = 0; a < K; a++)

  00040	33 f6		 xor	 esi, esi
$LL13@my_vectori:

; 30   : 					for (int c = 0; c < K; c++) {

  00042	33 d2		 xor	 edx, edx
$LL16@my_vectori:

; 31   : 						__m128 const_value = _mm_set1_ps(left[i][k][a][c]);

  00044	8b 4d f0	 mov	 ecx, DWORD PTR _left$1$[ebp]
  00047	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]

; 32   : 						for (int b = 0; b < K; b += 4) {
; 33   : 							__m128 string_value = _mm_load_ps(&right[k][j][c][b]);
; 34   : 							__m128 res_value = _mm_load_ps(&res[i][j][a][b]);
; 35   : 							res_value = _mm_add_ps(res_value, _mm_mul_ps(string_value, const_value));
; 36   : 							_mm_store_ps(&res[i][j][a][b], res_value);

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR tv672[ebp]
  0004d	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  00050	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  00053	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  00058	8b 43 08	 mov	 eax, DWORD PTR _res$[ebx]
  0005b	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  00064	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  00067	8b 45 ec	 mov	 eax, DWORD PTR _right$1$[ebp]
  0006a	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  0006d	8b 7d fc	 mov	 edi, DWORD PTR tv672[ebp]
  00070	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  00073	8b 7d f8	 mov	 edi, DWORD PTR tv674[ebp]
  00076	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00079	83 c2 04	 add	 edx, 4
  0007c	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  0007f	8b 43 08	 mov	 eax, DWORD PTR _res$[ebx]
  00082	0f 59 c8	 mulps	 xmm1, xmm0
  00085	0f 58 09	 addps	 xmm1, XMMWORD PTR [ecx]
  00088	0f 11 09	 movups	 XMMWORD PTR [ecx], xmm1
  0008b	83 fa 10	 cmp	 edx, 16			; 00000010H
  0008e	7c b4		 jl	 SHORT $LL16@my_vectori

; 29   : 				for (int a = 0; a < K; a++)

  00090	83 c6 04	 add	 esi, 4
  00093	83 fe 10	 cmp	 esi, 16			; 00000010H
  00096	7c aa		 jl	 SHORT $LL13@my_vectori

; 28   : 			for (int k = 0; k < N; k++)

  00098	83 c7 04	 add	 edi, 4
  0009b	89 7d f8	 mov	 DWORD PTR tv674[ebp], edi
  0009e	81 ff 00 02 00
	00		 cmp	 edi, 512		; 00000200H
  000a4	7c 9a		 jl	 SHORT $LL10@my_vectori

; 27   : 		for (int j = 0; j < N; j++)

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR tv672[ebp]
  000a9	83 c1 04	 add	 ecx, 4
  000ac	89 4d fc	 mov	 DWORD PTR tv672[ebp], ecx
  000af	81 f9 00 02 00
	00		 cmp	 ecx, 512		; 00000200H
  000b5	0f 8c 7a ff ff
	ff		 jl	 $LL7@my_vectori

; 26   : 	for (int i = 0; i < N; i++)

  000bb	83 c0 04	 add	 eax, 4
  000be	83 6d f4 01	 sub	 DWORD PTR tv671[ebp], 1
  000c2	89 43 08	 mov	 DWORD PTR _res$[ebx], eax
  000c5	0f 85 65 ff ff
	ff		 jne	 $LL4@my_vectori

; 37   : 						}
; 38   : 					}
; 39   : }

  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	8b e3		 mov	 esp, ebx
  000d2	5b		 pop	 ebx
  000d3	c3		 ret	 0
?my_vectorize@@YAXPAPAPAPAM00@Z ENDP			; my_vectorize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
;	COMDAT ?init_matrix@@YAXAAPAPAPAPAMHH_N@Z
_TEXT	SEGMENT
tv365 = -12						; size = 4
_matrix$1$ = -8						; size = 4
tv364 = -4						; size = 4
_k$dead$ = 8						; size = 4
_is_rand$ = 12						; size = 1
?init_matrix@@YAXAAPAPAPAPAMHH_N@Z PROC			; init_matrix, COMDAT
; _matrix$ = ecx
; _n$dead$ = edx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b d9		 mov	 ebx, ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  0000b	6a 00		 push	 0
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 42   : {

  0000d	89 5d f8	 mov	 DWORD PTR _matrix$1$[ebp], ebx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 43   : 	srand(time(0));

  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand

; 44   : 	matrix = (float****)_aligned_malloc(n * sizeof(float***), 16);

  0001d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___aligned_malloc
  00023	6a 10		 push	 16			; 00000010H
  00025	68 00 02 00 00	 push	 512			; 00000200H
  0002a	ff d6		 call	 esi
  0002c	83 c4 10	 add	 esp, 16			; 00000010H
  0002f	89 03		 mov	 DWORD PTR [ebx], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  00031	33 ff		 xor	 edi, edi
  00033	89 7d fc	 mov	 DWORD PTR tv364[ebp], edi
$LL4@init_matri:
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 46   : 		matrix[i] = (float***)_aligned_malloc(n * sizeof(float**), 16);

  00036	6a 10		 push	 16			; 00000010H
  00038	68 00 02 00 00	 push	 512			; 00000200H
  0003d	ff d6		 call	 esi
  0003f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00041	83 c4 08	 add	 esp, 8
  00044	33 f6		 xor	 esi, esi
  00046	89 75 f4	 mov	 DWORD PTR tv365[ebp], esi
  00049	89 04 0f	 mov	 DWORD PTR [edi+ecx], eax
  0004c	0f 1f 40 00	 npad	 4
$LL7@init_matri:

; 48   : 			matrix[i][j] = (float**)_aligned_malloc(k * sizeof(float*), 16);

  00050	6a 10		 push	 16			; 00000010H
  00052	6a 10		 push	 16			; 00000010H
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0005a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0005c	83 c4 08	 add	 esp, 8
  0005f	33 db		 xor	 ebx, ebx
  00061	8b 0c 39	 mov	 ecx, DWORD PTR [ecx+edi]
  00064	89 04 0e	 mov	 DWORD PTR [esi+ecx], eax
  00067	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL10@init_matri:

; 50   : 				matrix[i][j][a] = (float*)_aligned_malloc(k * sizeof(float), 16);

  00070	6a 10		 push	 16			; 00000010H
  00072	6a 10		 push	 16			; 00000010H
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _matrix$1$[ebp]
  0007d	83 c4 08	 add	 esp, 8
  00080	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00082	8b 0c 39	 mov	 ecx, DWORD PTR [ecx+edi]
  00085	33 ff		 xor	 edi, edi
  00087	8b 0c 31	 mov	 ecx, DWORD PTR [ecx+esi]
  0008a	89 04 0b	 mov	 DWORD PTR [ebx+ecx], eax
  0008d	8b 4d fc	 mov	 ecx, DWORD PTR tv364[ebp]
$LL13@init_matri:

; 51   : 				for (int b = 0; b < k; b++)
; 52   : 					matrix[i][j][a][b] = is_rand?(double)(rand() / 100) / (double)(rand() / 100):0;

  00090	80 7d 0c 00	 cmp	 BYTE PTR _is_rand$[ebp], 0
  00094	74 4e		 je	 SHORT $LN15@init_matri
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  0009c	8b c8		 mov	 ecx, eax
  0009e	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000a3	f7 e9		 imul	 ecx
  000a5	c1 fa 05	 sar	 edx, 5
  000a8	8b f2		 mov	 esi, edx
  000aa	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  000ad	03 f2		 add	 esi, edx
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  000b5	8b c8		 mov	 ecx, eax
  000b7	66 0f 6e ce	 movd	 xmm1, esi
  000bb	8b 75 f4	 mov	 esi, DWORD PTR tv365[ebp]
  000be	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000c3	f7 e9		 imul	 ecx
  000c5	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  000c9	8b 4d fc	 mov	 ecx, DWORD PTR tv364[ebp]
  000cc	c1 fa 05	 sar	 edx, 5
  000cf	8b c2		 mov	 eax, edx
  000d1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000d4	03 c2		 add	 eax, edx
  000d6	66 0f 6e c0	 movd	 xmm0, eax
  000da	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000de	f2 0f 5e c8	 divsd	 xmm1, xmm0
  000e2	eb 03		 jmp	 SHORT $LN16@init_matri
$LN15@init_matri:
  000e4	0f 57 c9	 xorps	 xmm1, xmm1
$LN16@init_matri:
  000e7	8b 45 f8	 mov	 eax, DWORD PTR _matrix$1$[ebp]
  000ea	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  000f3	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  000f6	8b 04 18	 mov	 eax, DWORD PTR [eax+ebx]
  000f9	f3 0f 11 04 07	 movss	 DWORD PTR [edi+eax], xmm0
  000fe	83 c7 04	 add	 edi, 4
  00101	83 ff 10	 cmp	 edi, 16			; 00000010H
  00104	7c 8a		 jl	 SHORT $LL13@init_matri

; 49   : 			for (int a = 0; a < k; a++) {

  00106	8b 7d fc	 mov	 edi, DWORD PTR tv364[ebp]
  00109	83 c3 04	 add	 ebx, 4
  0010c	83 fb 10	 cmp	 ebx, 16			; 00000010H
  0010f	0f 8c 5b ff ff
	ff		 jl	 $LL10@init_matri

; 47   : 		for (int j = 0; j < n; j++) {

  00115	8b 5d f8	 mov	 ebx, DWORD PTR _matrix$1$[ebp]
  00118	83 c6 04	 add	 esi, 4
  0011b	89 75 f4	 mov	 DWORD PTR tv365[ebp], esi
  0011e	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  00124	0f 8c 26 ff ff
	ff		 jl	 $LL7@init_matri

; 45   : 	for (int i = 0; i < n; i++) {

  0012a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___aligned_malloc
  00130	83 c7 04	 add	 edi, 4
  00133	89 7d fc	 mov	 DWORD PTR tv364[ebp], edi
  00136	81 ff 00 02 00
	00		 cmp	 edi, 512		; 00000200H
  0013c	0f 8c f4 fe ff
	ff		 jl	 $LL4@init_matri

; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : }

  00142	5f		 pop	 edi
  00143	5e		 pop	 esi
  00144	5b		 pop	 ebx
  00145	8b e5		 mov	 esp, ebp
  00147	5d		 pop	 ebp
  00148	c3		 ret	 0
?init_matrix@@YAXAAPAPAPAPAMHH_N@Z ENDP			; init_matrix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
;	COMDAT _main
_TEXT	SEGMENT
tv2382 = -80						; size = 4
tv2377 = -80						; size = 4
tv2270 = -80						; size = 4
tv2383 = -76						; size = 4
_matrix$1$ = -76					; size = 4
tv2397 = -72						; size = 4
tv2391 = -72						; size = 4
tv2376 = -68						; size = 4
_i$1$ = -68						; size = 4
tv2385 = -64						; size = 4
tv2378 = -64						; size = 4
tv2374 = -60						; size = 4
tv2269 = -60						; size = 4
tv2375 = -56						; size = 4
tv2348 = -56						; size = 4
_start$2$ = -52						; size = 4
_start$1$ = -52						; size = 4
tv2389 = -48						; size = 4
tv2370 = -44						; size = 4
tv2372 = -40						; size = 4
tv2262 = -36						; size = 4
tv2268 = -32						; size = 4
tv2263 = -28						; size = 4
tv2371 = -24						; size = 4
tv2373 = -20						; size = 4
_matrix$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_main	PROC						; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 50	 sub	 esp, 80			; 00000050H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 4c	 mov	 DWORD PTR __$ArrayPad$[esp+80], eax
  00014	56		 push	 esi

; 60   : 	float ****matrix[3];
; 61   : 	for (int i = 0; i < 3; i++)

  00015	33 f6		 xor	 esi, esi
  00017	57		 push	 edi
  00018	89 74 24 14	 mov	 DWORD PTR _i$1$[esp+88], esi
  0001c	0f 1f 40 00	 npad	 4
$LL4@main:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  00020	6a 00		 push	 0
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00028	83 c4 04	 add	 esp, 4
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 43   : 	srand(time(0));

  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand
  00032	83 c4 04	 add	 esp, 4

; 44   : 	matrix = (float****)_aligned_malloc(n * sizeof(float***), 16);

  00035	6a 10		 push	 16			; 00000010H
  00037	68 00 02 00 00	 push	 512			; 00000200H
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  00042	8b f8		 mov	 edi, eax
  00044	83 c4 08	 add	 esp, 8
  00047	89 7c b4 48	 mov	 DWORD PTR _matrix$[esp+esi*4+88], edi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  0004b	33 f6		 xor	 esi, esi
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 44   : 	matrix = (float****)_aligned_malloc(n * sizeof(float***), 16);

  0004d	89 7c 24 10	 mov	 DWORD PTR tv2391[esp+88], edi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  00051	89 74 24 08	 mov	 DWORD PTR tv2382[esp+88], esi
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL9@main:
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 46   : 		matrix[i] = (float***)_aligned_malloc(n * sizeof(float**), 16);

  00060	6a 10		 push	 16			; 00000010H
  00062	68 00 02 00 00	 push	 512			; 00000200H
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0006d	83 c4 08	 add	 esp, 8
  00070	89 04 3e	 mov	 DWORD PTR [esi+edi], eax
  00073	33 ff		 xor	 edi, edi
  00075	89 7c 24 0c	 mov	 DWORD PTR tv2383[esp+88], edi
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL12@main:

; 48   : 			matrix[i][j] = (float**)_aligned_malloc(k * sizeof(float*), 16);

  00080	6a 10		 push	 16			; 00000010H
  00082	6a 10		 push	 16			; 00000010H
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0008a	8b 4c 24 18	 mov	 ecx, DWORD PTR tv2391[esp+96]
  0008e	83 c4 08	 add	 esp, 8
  00091	8b 0c 0e	 mov	 ecx, DWORD PTR [esi+ecx]
  00094	33 f6		 xor	 esi, esi
  00096	89 74 24 18	 mov	 DWORD PTR tv2385[esp+88], esi
  0009a	89 04 0f	 mov	 DWORD PTR [edi+ecx], eax
  0009d	0f 1f 00	 npad	 3
$LL15@main:

; 50   : 				matrix[i][j][a] = (float*)_aligned_malloc(k * sizeof(float), 16);

  000a0	6a 10		 push	 16			; 00000010H
  000a2	6a 10		 push	 16			; 00000010H
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  000aa	8b 4c 24 10	 mov	 ecx, DWORD PTR tv2382[esp+96]
  000ae	83 c4 08	 add	 esp, 8
  000b1	8b 54 24 10	 mov	 edx, DWORD PTR tv2391[esp+88]
  000b5	8b 0c 11	 mov	 ecx, DWORD PTR [ecx+edx]
  000b8	8b 0c 39	 mov	 ecx, DWORD PTR [ecx+edi]
  000bb	33 ff		 xor	 edi, edi
  000bd	89 04 0e	 mov	 DWORD PTR [esi+ecx], eax
  000c0	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv2383[esp+88]
$LL18@main:

; 62   : 		init_matrix(matrix[i], N, K, i != 2);

  000c4	83 7c 24 14 02	 cmp	 DWORD PTR _i$1$[esp+88], 2

; 52   : 					matrix[i][j][a][b] = is_rand?(double)(rand() / 100) / (double)(rand() / 100):0;

  000c9	74 54		 je	 SHORT $LN20@main
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  000d1	8b c8		 mov	 ecx, eax
  000d3	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000d8	f7 e9		 imul	 ecx
  000da	c1 fa 05	 sar	 edx, 5
  000dd	8b f2		 mov	 esi, edx
  000df	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  000e2	03 f2		 add	 esi, edx
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  000ea	8b c8		 mov	 ecx, eax
  000ec	66 0f 6e ce	 movd	 xmm1, esi
  000f0	8b 74 24 18	 mov	 esi, DWORD PTR tv2385[esp+88]
  000f4	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  000f9	f7 e9		 imul	 ecx
  000fb	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  000ff	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv2383[esp+88]
  00103	c1 fa 05	 sar	 edx, 5
  00106	8b c2		 mov	 eax, edx
  00108	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0010b	03 c2		 add	 eax, edx
  0010d	8b 54 24 10	 mov	 edx, DWORD PTR tv2391[esp+88]
  00111	66 0f 6e c0	 movd	 xmm0, eax
  00115	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00119	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0011d	eb 03		 jmp	 SHORT $LN21@main
$LN20@main:
  0011f	0f 57 c9	 xorps	 xmm1, xmm1
$LN21@main:
  00122	8b 44 24 08	 mov	 eax, DWORD PTR tv2382[esp+88]
  00126	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  0012a	8b 04 10	 mov	 eax, DWORD PTR [eax+edx]
  0012d	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  00130	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  00133	f3 0f 11 04 07	 movss	 DWORD PTR [edi+eax], xmm0
  00138	83 c7 04	 add	 edi, 4
  0013b	83 ff 10	 cmp	 edi, 16			; 00000010H
  0013e	7c 84		 jl	 SHORT $LL18@main

; 49   : 			for (int a = 0; a < k; a++) {

  00140	8b 7c 24 0c	 mov	 edi, DWORD PTR tv2383[esp+88]
  00144	83 c6 04	 add	 esi, 4
  00147	89 74 24 18	 mov	 DWORD PTR tv2385[esp+88], esi
  0014b	83 fe 10	 cmp	 esi, 16			; 00000010H
  0014e	0f 8c 4c ff ff
	ff		 jl	 $LL15@main

; 47   : 		for (int j = 0; j < n; j++) {

  00154	8b 74 24 08	 mov	 esi, DWORD PTR tv2382[esp+88]
  00158	83 c7 04	 add	 edi, 4
  0015b	89 7c 24 0c	 mov	 DWORD PTR tv2383[esp+88], edi
  0015f	81 ff 00 02 00
	00		 cmp	 edi, 512		; 00000200H
  00165	0f 8c 15 ff ff
	ff		 jl	 $LL12@main

; 45   : 	for (int i = 0; i < n; i++) {

  0016b	8b 7c 24 10	 mov	 edi, DWORD PTR tv2391[esp+88]
  0016f	83 c6 04	 add	 esi, 4
  00172	89 74 24 08	 mov	 DWORD PTR tv2382[esp+88], esi
  00176	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  0017c	0f 8c de fe ff
	ff		 jl	 $LL9@main

; 60   : 	float ****matrix[3];
; 61   : 	for (int i = 0; i < 3; i++)

  00182	8b 74 24 14	 mov	 esi, DWORD PTR _i$1$[esp+88]
  00186	46		 inc	 esi
  00187	89 74 24 14	 mov	 DWORD PTR _i$1$[esp+88], esi
  0018b	83 fe 03	 cmp	 esi, 3
  0018e	0f 8c 8c fe ff
	ff		 jl	 $LL4@main

; 63   : 	DWORD start = GetTickCount64();

  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount64@0
  0019a	8b 4c 24 48	 mov	 ecx, DWORD PTR _matrix$[esp+88]
  0019e	89 44 24 24	 mov	 DWORD PTR _start$1$[esp+88], eax
  001a2	8b 44 24 50	 mov	 eax, DWORD PTR _matrix$[esp+96]
  001a6	8b d0		 mov	 edx, eax
  001a8	2b c8		 sub	 ecx, eax
  001aa	89 44 24 0c	 mov	 DWORD PTR _matrix$1$[esp+88], eax
  001ae	89 54 24 1c	 mov	 DWORD PTR tv2374[esp+88], edx
  001b2	89 4c 24 30	 mov	 DWORD PTR tv2372[esp+88], ecx
  001b6	c7 44 24 20 80
	00 00 00	 mov	 DWORD PTR tv2375[esp+88], 128 ; 00000080H
  001be	66 90		 npad	 2
$LL27@main:
  001c0	8b 0c 11	 mov	 ecx, DWORD PTR [ecx+edx]
  001c3	8b 44 24 4c	 mov	 eax, DWORD PTR _matrix$[esp+92]
  001c7	8b 32		 mov	 esi, DWORD PTR [edx]
  001c9	2b c1		 sub	 eax, ecx

; 17   : 		for (int j = 0; j < N; j++)

  001cb	33 d2		 xor	 edx, edx
  001cd	89 4c 24 40	 mov	 DWORD PTR tv2371[esp+88], ecx
  001d1	89 74 24 44	 mov	 DWORD PTR tv2373[esp+88], esi
  001d5	89 44 24 2c	 mov	 DWORD PTR tv2370[esp+88], eax
  001d9	89 54 24 14	 mov	 DWORD PTR tv2376[esp+88], edx
  001dd	0f 1f 00	 npad	 3
$LL30@main:
  001e0	8b 3c 16	 mov	 edi, DWORD PTR [esi+edx]
  001e3	89 7c 24 3c	 mov	 DWORD PTR tv2263[esp+88], edi

; 18   : 			for (int k = 0; k < N; k++)

  001e7	89 4c 24 08	 mov	 DWORD PTR tv2377[esp+88], ecx
  001eb	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR tv2389[esp+88], 128 ; 00000080H
$LL33@main:

; 19   : 				for (int a = 0; a < K; a++)

  001f3	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  001f6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001f8	2b cf		 sub	 ecx, edi
  001fa	c7 44 24 10 04
	00 00 00	 mov	 DWORD PTR tv2397[esp+88], 4
  00202	89 4c 24 34	 mov	 DWORD PTR tv2262[esp+88], ecx
  00206	8b 34 02	 mov	 esi, DWORD PTR [edx+eax]
  00209	8b c7		 mov	 eax, edi
  0020b	89 74 24 38	 mov	 DWORD PTR tv2268[esp+88], esi
  0020f	89 44 24 18	 mov	 DWORD PTR tv2378[esp+88], eax
$LL36@main:
  00213	8b 14 08	 mov	 edx, DWORD PTR [eax+ecx]

; 20   : 					for (int c = 0; c < K; c++)

  00216	8b fe		 mov	 edi, esi

; 21   : 						for (int b = 0; b < K; b++)
; 22   : 							res[i][j][a][b] += left[i][k][a][c] * right[k][j][c][b];

  00218	8b 08		 mov	 ecx, DWORD PTR [eax]
  0021a	2b fa		 sub	 edi, edx
  0021c	be 04 00 00 00	 mov	 esi, 4
$LL39@main:
  00221	8b 04 3a	 mov	 eax, DWORD PTR [edx+edi]
  00224	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00228	f3 0f 59 02	 mulss	 xmm0, DWORD PTR [edx]
  0022c	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  00230	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00234	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00239	f3 0f 59 02	 mulss	 xmm0, DWORD PTR [edx]
  0023d	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  00242	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0
  00247	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0024c	f3 0f 59 02	 mulss	 xmm0, DWORD PTR [edx]
  00250	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [ecx+8]
  00255	f3 0f 11 41 08	 movss	 DWORD PTR [ecx+8], xmm0
  0025a	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0025f	f3 0f 59 02	 mulss	 xmm0, DWORD PTR [edx]
  00263	83 c2 04	 add	 edx, 4
  00266	f3 0f 58 41 0c	 addss	 xmm0, DWORD PTR [ecx+12]
  0026b	f3 0f 11 41 0c	 movss	 DWORD PTR [ecx+12], xmm0
  00270	83 ee 01	 sub	 esi, 1
  00273	75 ac		 jne	 SHORT $LL39@main

; 19   : 				for (int a = 0; a < K; a++)

  00275	8b 44 24 18	 mov	 eax, DWORD PTR tv2378[esp+88]
  00279	8b 4c 24 34	 mov	 ecx, DWORD PTR tv2262[esp+88]
  0027d	83 c0 04	 add	 eax, 4
  00280	83 6c 24 10 01	 sub	 DWORD PTR tv2397[esp+88], 1
  00285	8b 74 24 38	 mov	 esi, DWORD PTR tv2268[esp+88]
  00289	89 44 24 18	 mov	 DWORD PTR tv2378[esp+88], eax
  0028d	75 84		 jne	 SHORT $LL36@main

; 18   : 			for (int k = 0; k < N; k++)

  0028f	8b 4c 24 08	 mov	 ecx, DWORD PTR tv2377[esp+88]
  00293	8b 54 24 14	 mov	 edx, DWORD PTR tv2376[esp+88]
  00297	83 c1 04	 add	 ecx, 4
  0029a	83 6c 24 28 01	 sub	 DWORD PTR tv2389[esp+88], 1
  0029f	8b 7c 24 3c	 mov	 edi, DWORD PTR tv2263[esp+88]
  002a3	8b 44 24 2c	 mov	 eax, DWORD PTR tv2370[esp+88]
  002a7	89 4c 24 08	 mov	 DWORD PTR tv2377[esp+88], ecx
  002ab	0f 85 42 ff ff
	ff		 jne	 $LL33@main

; 17   : 		for (int j = 0; j < N; j++)

  002b1	8b 4c 24 40	 mov	 ecx, DWORD PTR tv2371[esp+88]
  002b5	83 c2 04	 add	 edx, 4
  002b8	8b 74 24 44	 mov	 esi, DWORD PTR tv2373[esp+88]
  002bc	89 54 24 14	 mov	 DWORD PTR tv2376[esp+88], edx
  002c0	81 fa 00 02 00
	00		 cmp	 edx, 512		; 00000200H
  002c6	0f 8c 14 ff ff
	ff		 jl	 $LL30@main

; 16   : 	for (int i = 0; i < N; i++)

  002cc	8b 54 24 1c	 mov	 edx, DWORD PTR tv2374[esp+88]
  002d0	8b 4c 24 30	 mov	 ecx, DWORD PTR tv2372[esp+88]
  002d4	83 c2 04	 add	 edx, 4
  002d7	83 6c 24 20 01	 sub	 DWORD PTR tv2375[esp+88], 1
  002dc	89 54 24 1c	 mov	 DWORD PTR tv2374[esp+88], edx
  002e0	0f 85 da fe ff
	ff		 jne	 $LL27@main

; 64   : 	auto_vectorize(matrix[0], matrix[1], matrix[2]);
; 65   : 	DWORD duration = GetTickCount64() - start;

  002e6	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount64@0
  002ec	ff d6		 call	 esi
  002ee	2b 44 24 24	 sub	 eax, DWORD PTR _start$1$[esp+88]

; 66   : 	cout << "auto_vec: " << duration << " ticks" << endl;

  002f2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0L@HNBJPKEP@auto_vec?3?5@
  002f7	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002fc	50		 push	 eax
  002fd	51		 push	 ecx
  002fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00304	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00309	83 c4 04	 add	 esp, 4
  0030c	8b c8		 mov	 ecx, eax
  0030e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
  00314	51		 push	 ecx
  00315	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06MALMBFOP@?5ticks@
  0031a	8b c8		 mov	 ecx, eax
  0031c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00321	83 c4 04	 add	 esp, 4
  00324	8b c8		 mov	 ecx, eax
  00326	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 67   : 	start = GetTickCount64();

  0032c	ff d6		 call	 esi
  0032e	89 44 24 24	 mov	 DWORD PTR _start$2$[esp+88], eax
  00332	8b 44 24 50	 mov	 eax, DWORD PTR _matrix$[esp+96]
  00336	c7 44 24 1c 80
	00 00 00	 mov	 DWORD PTR tv2269[esp+88], 128 ; 00000080H
  0033e	66 90		 npad	 2
$LL47@main:

; 27   : 		for (int j = 0; j < N; j++)

  00340	33 c9		 xor	 ecx, ecx
  00342	89 4c 24 08	 mov	 DWORD PTR tv2270[esp+88], ecx
$LL50@main:

; 28   : 			for (int k = 0; k < N; k++)

  00346	33 ff		 xor	 edi, edi
  00348	89 7c 24 20	 mov	 DWORD PTR tv2348[esp+88], edi
  0034c	0f 1f 40 00	 npad	 4
$LL53@main:

; 29   : 				for (int a = 0; a < K; a++)

  00350	33 f6		 xor	 esi, esi
$LL56@main:

; 30   : 					for (int c = 0; c < K; c++) {

  00352	33 d2		 xor	 edx, edx
$LL59@main:

; 31   : 						__m128 const_value = _mm_set1_ps(left[i][k][a][c]);

  00354	8b 4c 24 30	 mov	 ecx, DWORD PTR tv2372[esp+88]
  00358	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]

; 32   : 						for (int b = 0; b < K; b += 4) {
; 33   : 							__m128 string_value = _mm_load_ps(&right[k][j][c][b]);
; 34   : 							__m128 res_value = _mm_load_ps(&res[i][j][a][b]);
; 35   : 							res_value = _mm_add_ps(res_value, _mm_mul_ps(string_value, const_value));
; 36   : 							_mm_store_ps(&res[i][j][a][b], res_value);

  0035b	8b 4c 24 08	 mov	 ecx, DWORD PTR tv2270[esp+88]
  0035f	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00362	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  00365	f3 0f 10 04 10	 movss	 xmm0, DWORD PTR [eax+edx]
  0036a	8b 44 24 0c	 mov	 eax, DWORD PTR _matrix$1$[esp+88]
  0036e	0f c6 c0 00	 shufps	 xmm0, xmm0, 0
  00372	8b 00		 mov	 eax, DWORD PTR [eax]
  00374	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  00377	8b 0c 06	 mov	 ecx, DWORD PTR [esi+eax]
  0037a	8b 44 24 4c	 mov	 eax, DWORD PTR _matrix$[esp+92]
  0037e	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00381	8b 7c 24 08	 mov	 edi, DWORD PTR tv2270[esp+88]
  00385	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  00388	8b 7c 24 20	 mov	 edi, DWORD PTR tv2348[esp+88]
  0038c	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0038f	83 c2 04	 add	 edx, 4
  00392	0f 10 08	 movups	 xmm1, XMMWORD PTR [eax]
  00395	8b 44 24 0c	 mov	 eax, DWORD PTR _matrix$1$[esp+88]
  00399	0f 59 c8	 mulps	 xmm1, xmm0
  0039c	0f 58 09	 addps	 xmm1, XMMWORD PTR [ecx]
  0039f	0f 11 09	 movups	 XMMWORD PTR [ecx], xmm1
  003a2	83 fa 10	 cmp	 edx, 16			; 00000010H
  003a5	7c ad		 jl	 SHORT $LL59@main

; 29   : 				for (int a = 0; a < K; a++)

  003a7	83 c6 04	 add	 esi, 4
  003aa	83 fe 10	 cmp	 esi, 16			; 00000010H
  003ad	7c a3		 jl	 SHORT $LL56@main

; 28   : 			for (int k = 0; k < N; k++)

  003af	83 c7 04	 add	 edi, 4
  003b2	89 7c 24 20	 mov	 DWORD PTR tv2348[esp+88], edi
  003b6	81 ff 00 02 00
	00		 cmp	 edi, 512		; 00000200H
  003bc	7c 92		 jl	 SHORT $LL53@main

; 27   : 		for (int j = 0; j < N; j++)

  003be	8b 4c 24 08	 mov	 ecx, DWORD PTR tv2270[esp+88]
  003c2	83 c1 04	 add	 ecx, 4
  003c5	89 4c 24 08	 mov	 DWORD PTR tv2270[esp+88], ecx
  003c9	81 f9 00 02 00
	00		 cmp	 ecx, 512		; 00000200H
  003cf	0f 8c 71 ff ff
	ff		 jl	 $LL50@main

; 23   : }
; 24   : void my_vectorize(float**** left, float**** right, float**** res)
; 25   : {
; 26   : 	for (int i = 0; i < N; i++)

  003d5	83 c0 04	 add	 eax, 4
  003d8	83 6c 24 1c 01	 sub	 DWORD PTR tv2269[esp+88], 1
  003dd	89 44 24 0c	 mov	 DWORD PTR _matrix$1$[esp+88], eax
  003e1	0f 85 59 ff ff
	ff		 jne	 $LL47@main

; 68   : 	my_vectorize(matrix[0], matrix[1], matrix[2]);
; 69   : 	duration = GetTickCount64() - start;

  003e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount64@0
  003ed	2b 44 24 24	 sub	 eax, DWORD PTR _start$2$[esp+88]

; 70   : 	cout << "my_vec: " << duration << " ticks" << endl;

  003f1	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08MLBKJEKP@my_vec?3?5@
  003f6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  003fb	50		 push	 eax
  003fc	51		 push	 ecx
  003fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00403	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00408	83 c4 04	 add	 esp, 4
  0040b	8b c8		 mov	 ecx, eax
  0040d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
  00413	51		 push	 ecx
  00414	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06MALMBFOP@?5ticks@
  00419	8b c8		 mov	 ecx, eax
  0041b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00420	83 c4 04	 add	 esp, 4
  00423	8b c8		 mov	 ecx, eax
  00425	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 71   : 	system("pause > NUL");

  0042b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NADFNJG@pause?5?$DO?5NUL@
  00430	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__system

; 72   : 	return 0;
; 73   : }

  00436	8b 4c 24 58	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+92]
  0043a	83 c4 04	 add	 esp, 4
  0043d	33 c0		 xor	 eax, eax
  0043f	5f		 pop	 edi
  00440	5e		 pop	 esi
  00441	33 cc		 xor	 ecx, esp
  00443	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00448	8b e5		 mov	 esp, ebp
  0044a	5d		 pop	 ebp
  0044b	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
END
