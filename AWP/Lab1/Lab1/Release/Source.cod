; Listing generated by Microsoft (R) Optimizing Compiler Version 19.23.28106.4 

	TITLE	d:\univer\6 sem\awp\lab1\lab1\source.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_C@_0BN@MGAFAJLF@input?5contains?5matrix?5size?3?5@ ; `string'
PUBLIC	??_C@_06MALMBFOP@?5ticks@			; `string'
PUBLIC	??_C@_0L@HNBJPKEP@auto_vec?3?5@			; `string'
PUBLIC	??_C@_08MLBKJEKP@my_vec?3?5@			; `string'
PUBLIC	??_C@_0M@NADFNJG@pause?5?$DO?5NUL@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__TI1?AVexception@std@@
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__CTA1?AVexception@std@@
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAI@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp____std_terminate:PROC
EXTRN	__imp___time64:PROC
EXTRN	__imp__GetTickCount64@0:PROC
EXTRN	__imp__system:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___aligned_malloc:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp__srand:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp____CxxFrameHandler3:PROC
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CTA1?AVexception@std@@
xdata$x	SEGMENT
__CTA1?AVexception@std@@ DD 01H
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT __TI1?AVexception@std@@
xdata$x	SEGMENT
__TI1?AVexception@std@@ DD 00H
	DD	FLAT:??1exception@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA1?AVexception@std@@
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0M@NADFNJG@pause?5?$DO?5NUL@
CONST	SEGMENT
??_C@_0M@NADFNJG@pause?5?$DO?5NUL@ DB 'pause > NUL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLBKJEKP@my_vec?3?5@
CONST	SEGMENT
??_C@_08MLBKJEKP@my_vec?3?5@ DB 'my_vec: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HNBJPKEP@auto_vec?3?5@
CONST	SEGMENT
??_C@_0L@HNBJPKEP@auto_vec?3?5@ DB 'auto_vec: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MALMBFOP@?5ticks@
CONST	SEGMENT
??_C@_06MALMBFOP@?5ticks@ DB ' ticks', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MGAFAJLF@input?5contains?5matrix?5size?3?5@
CONST	SEGMENT
??_C@_0BN@MGAFAJLF@input?5contains?5matrix?5size?3?5@ DB 'input contains '
	DB	'matrix size: ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	_main
PUBLIC	?init_matrix@@YAXAAPAPAPAPAMHH_N@Z		; init_matrix
PUBLIC	?my_vectorize@@YAXPAPAPAPAM00I@Z		; my_vectorize
PUBLIC	?auto_vectorize@@YAXPAPAPAPAM00I@Z		; auto_vectorize
PUBLIC	?loop@@YAXPAMM0H@Z				; loop
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@XZ			; std::exception::exception
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___std_terminate:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	04H
	DD	FLAT:___std_terminate
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@XZ
_TEXT	SEGMENT
??0exception@std@@QAE@XZ PROC				; std::exception::exception, COMDAT
; _this$ = ecx

; 51   :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 52   :     }

  0000e	8b c1		 mov	 eax, ecx
  00010	c3		 ret	 0
??0exception@std@@QAE@XZ ENDP				; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 69   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 70   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_copy
  00024	83 c4 08	 add	 esp, 8

; 71   :     }

  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 87   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00010	59		 pop	 ecx

; 88   :     }

  00011	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 92   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 93   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 86   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 87   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____std_exception_destroy
  00016	83 c4 04	 add	 esp, 4
  00019	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001d	74 0b		 je	 SHORT $LN6@scalar
  0001f	6a 0c		 push	 12			; 0000000cH
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00027	83 c4 08	 add	 esp, 8
$LN6@scalar:
  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
_TEXT	SEGMENT
_time	PROC
; __Time$dead$ = ecx

; 536  :             return _time64(_Time);

  00000	6a 00		 push	 0
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00008	83 c4 04	 add	 esp, 4

; 537  :         }

  0000b	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
_TEXT	SEGMENT
tv1428 = -12						; size = 4
tv1427 = -12						; size = 4
_res_ms$1$ = -8						; size = 4
_string_ms$1$ = -4					; size = 4
tv1421 = 8						; size = 4
_Kd16$ = 8						; size = 4
?loop@@YAXPAMM0H@Z PROC					; loop
; _res_ms$ = ecx
; _const_value$ = xmm1s
; _string_ms$ = edx

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 14   : 	for (int i = 0; i < 16*Kd16; i++){

  00008	8b 75 08	 mov	 esi, DWORD PTR _Kd16$[ebp]
  0000b	0f 28 d1	 movaps	 xmm2, xmm1
  0000e	57		 push	 edi
  0000f	8b f9		 mov	 edi, ecx
  00011	c1 e6 04	 shl	 esi, 4
  00014	8b da		 mov	 ebx, edx
  00016	89 7d f8	 mov	 DWORD PTR _res_ms$1$[ebp], edi
  00019	0f 28 da	 movaps	 xmm3, xmm2
  0001c	89 5d fc	 mov	 DWORD PTR _string_ms$1$[ebp], ebx
  0001f	33 c9		 xor	 ecx, ecx
  00021	0f c6 db 00	 shufps	 xmm3, xmm3, 0
  00025	89 75 08	 mov	 DWORD PTR _Kd16$[ebp], esi
  00028	85 f6		 test	 esi, esi
  0002a	0f 8e 49 01 00
	00		 jle	 $LN16@loop
  00030	83 fe 10	 cmp	 esi, 16			; 00000010H
  00033	0f 82 7c 00 00
	00		 jb	 $LN9@loop
  00039	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  0003c	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  0003f	8d 56 ff	 lea	 edx, DWORD PTR [esi-1]
  00042	8d 14 97	 lea	 edx, DWORD PTR [edi+edx*4]
  00045	3b f8		 cmp	 edi, eax
  00047	77 04		 ja	 SHORT $LN10@loop
  00049	3b d3		 cmp	 edx, ebx
  0004b	73 68		 jae	 SHORT $LN9@loop
$LN10@loop:
  0004d	8b f3		 mov	 esi, ebx
  0004f	8d 53 30	 lea	 edx, DWORD PTR [ebx+48]
  00052	2b f7		 sub	 esi, edi
  00054	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  00057	89 75 f4	 mov	 DWORD PTR tv1428[ebp], esi
  0005a	8b 75 08	 mov	 esi, DWORD PTR _Kd16$[ebp]
  0005d	8b 5d f4	 mov	 ebx, DWORD PTR tv1428[ebp]
$LL4@loop:

; 15   : 		res_ms[i] += const_value * string_ms[i];

  00060	0f 10 4a d0	 movups	 xmm1, XMMWORD PTR [edx-48]
  00064	83 c1 10	 add	 ecx, 16			; 00000010H
  00067	0f 10 40 f0	 movups	 xmm0, XMMWORD PTR [eax-16]
  0006b	0f 59 cb	 mulps	 xmm1, xmm3
  0006e	0f 58 c8	 addps	 xmm1, xmm0
  00071	0f 11 48 f0	 movups	 XMMWORD PTR [eax-16], xmm1
  00075	0f 10 0c 03	 movups	 xmm1, XMMWORD PTR [ebx+eax]
  00079	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0007c	0f 59 cb	 mulps	 xmm1, xmm3
  0007f	0f 58 c8	 addps	 xmm1, xmm0
  00082	0f 11 08	 movups	 XMMWORD PTR [eax], xmm1
  00085	0f 10 4a f0	 movups	 xmm1, XMMWORD PTR [edx-16]
  00089	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0008d	0f 59 cb	 mulps	 xmm1, xmm3
  00090	0f 58 c8	 addps	 xmm1, xmm0
  00093	0f 11 48 10	 movups	 XMMWORD PTR [eax+16], xmm1
  00097	0f 10 0a	 movups	 xmm1, XMMWORD PTR [edx]
  0009a	83 c2 40	 add	 edx, 64			; 00000040H
  0009d	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [eax+32]
  000a1	0f 59 cb	 mulps	 xmm1, xmm3
  000a4	0f 58 c8	 addps	 xmm1, xmm0
  000a7	0f 11 48 20	 movups	 XMMWORD PTR [eax+32], xmm1
  000ab	83 c0 40	 add	 eax, 64			; 00000040H
  000ae	3b ce		 cmp	 ecx, esi
  000b0	7c ae		 jl	 SHORT $LL4@loop
  000b2	8b 5d fc	 mov	 ebx, DWORD PTR _string_ms$1$[ebp]
$LN9@loop:

; 14   : 	for (int i = 0; i < 16*Kd16; i++){

  000b5	3b ce		 cmp	 ecx, esi
  000b7	0f 8d bc 00 00
	00		 jge	 $LN16@loop
  000bd	8b c6		 mov	 eax, esi
  000bf	2b c1		 sub	 eax, ecx
  000c1	83 f8 04	 cmp	 eax, 4
  000c4	0f 8c 80 00 00
	00		 jl	 $LC17@loop
  000ca	8b 55 f8	 mov	 edx, DWORD PTR _res_ms$1$[ebp]
  000cd	8d 79 03	 lea	 edi, DWORD PTR [ecx+3]
  000d0	8d 3c bb	 lea	 edi, DWORD PTR [ebx+edi*4]
  000d3	2b da		 sub	 ebx, edx
  000d5	89 7d 08	 mov	 DWORD PTR tv1421[ebp], edi
  000d8	89 5d f4	 mov	 DWORD PTR tv1427[ebp], ebx
  000db	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  000de	8b d6		 mov	 edx, esi
  000e0	2b d1		 sub	 edx, ecx
  000e2	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000e5	83 ea 04	 sub	 edx, 4
  000e8	c1 ea 02	 shr	 edx, 2
  000eb	42		 inc	 edx
  000ec	8d 0c 91	 lea	 ecx, DWORD PTR [ecx+edx*4]
  000ef	90		 npad	 1
$LL18@loop:

; 15   : 		res_ms[i] += const_value * string_ms[i];

  000f0	f3 0f 10 47 f4	 movss	 xmm0, DWORD PTR [edi-12]
  000f5	f3 0f 59 c2	 mulss	 xmm0, xmm2
  000f9	f3 0f 58 40 fc	 addss	 xmm0, DWORD PTR [eax-4]
  000fe	f3 0f 11 40 fc	 movss	 DWORD PTR [eax-4], xmm0
  00103	f3 0f 10 04 03	 movss	 xmm0, DWORD PTR [ebx+eax]
  00108	f3 0f 59 c2	 mulss	 xmm0, xmm2
  0010c	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  00110	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00114	f3 0f 10 47 fc	 movss	 xmm0, DWORD PTR [edi-4]
  00119	f3 0f 59 c2	 mulss	 xmm0, xmm2
  0011d	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [eax+4]
  00122	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  00127	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  0012b	83 c7 10	 add	 edi, 16			; 00000010H
  0012e	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00132	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  00137	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  0013c	83 c0 10	 add	 eax, 16			; 00000010H
  0013f	83 ea 01	 sub	 edx, 1
  00142	75 ac		 jne	 SHORT $LL18@loop
  00144	8b 5d fc	 mov	 ebx, DWORD PTR _string_ms$1$[ebp]
  00147	8b 7d f8	 mov	 edi, DWORD PTR _res_ms$1$[ebp]
$LC17@loop:

; 14   : 	for (int i = 0; i < 16*Kd16; i++){

  0014a	3b ce		 cmp	 ecx, esi
  0014c	7d 2b		 jge	 SHORT $LN16@loop
  0014e	2b df		 sub	 ebx, edi
  00150	8d 04 8f	 lea	 eax, DWORD PTR [edi+ecx*4]
  00153	2b f1		 sub	 esi, ecx
  00155	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LC8@loop:

; 15   : 		res_ms[i] += const_value * string_ms[i];

  00160	f3 0f 10 04 03	 movss	 xmm0, DWORD PTR [ebx+eax]
  00165	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00169	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  0016d	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00171	83 c0 04	 add	 eax, 4
  00174	83 ee 01	 sub	 esi, 1
  00177	75 e7		 jne	 SHORT $LC8@loop
$LN16@loop:
  00179	5f		 pop	 edi

; 16   : 	}
; 17   : }

  0017a	5e		 pop	 esi
  0017b	5b		 pop	 ebx
  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	c3		 ret	 0
?loop@@YAXPAMM0H@Z ENDP					; loop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
_TEXT	SEGMENT
_right$1$ = -64						; size = 4
tv1378 = -60						; size = 4
tv1381 = -56						; size = 4
tv1380 = -52						; size = 4
tv1477 = -48						; size = 4
tv1479 = -44						; size = 4
tv1382 = -40						; size = 4
_left$1$ = -36						; size = 4
tv1386 = -32						; size = 4
tv1387 = -28						; size = 4
tv1388 = -24						; size = 4
tv1390 = -20						; size = 4
_res_ms$1$ = -16					; size = 4
tv1391 = -12						; size = 4
tv1389 = -8						; size = 4
tv1393 = -4						; size = 4
_res$ = 8						; size = 4
_K$ = 12						; size = 4
?auto_vectorize@@YAXPAPAPAPAM00I@Z PROC			; auto_vectorize
; _left$ = ecx
; _right$ = edx

; 20   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 21   : 	for (int i = 0; i < N; i++)

  00009	8b 7d 08	 mov	 edi, DWORD PTR _res$[ebp]
  0000c	8b c1		 mov	 eax, ecx
  0000e	8b da		 mov	 ebx, edx
  00010	c7 45 e0 40 00
	00 00		 mov	 DWORD PTR tv1386[ebp], 64 ; 00000040H
  00017	2b c7		 sub	 eax, edi
  00019	89 5d c0	 mov	 DWORD PTR _right$1$[ebp], ebx
  0001c	89 45 dc	 mov	 DWORD PTR _left$1$[ebp], eax
  0001f	90		 npad	 1
$LL4@auto_vecto:

; 22   : 		for (int j = 0; j < N; j++)

  00020	33 c9		 xor	 ecx, ecx
  00022	89 4d e4	 mov	 DWORD PTR tv1387[ebp], ecx
$LL7@auto_vecto:

; 23   : 			for (int k = 0; k < N; k++)

  00025	8b 75 0c	 mov	 esi, DWORD PTR _K$[ebp]
  00028	33 d2		 xor	 edx, edx
  0002a	89 55 e8	 mov	 DWORD PTR tv1388[ebp], edx
  0002d	0f 1f 00	 npad	 3
$LL10@auto_vecto:

; 24   : 				for (int a = 0; a < K; a++)

  00030	85 f6		 test	 esi, esi
  00032	0f 84 51 01 00
	00		 je	 $LN8@auto_vecto

; 26   : 						loop(res[i][j][a], left[i][k][a][c], right[k][j][c], K >> 4);

  00038	8b 04 1a	 mov	 eax, DWORD PTR [edx+ebx]
  0003b	8b de		 mov	 ebx, esi
  0003d	83 e3 f0	 and	 ebx, -16		; fffffff0H
  00040	89 75 ec	 mov	 DWORD PTR tv1390[ebp], esi
  00043	89 5d cc	 mov	 DWORD PTR tv1380[ebp], ebx
  00046	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00049	89 45 d8	 mov	 DWORD PTR tv1382[ebp], eax
  0004c	8b 07		 mov	 eax, DWORD PTR [edi]
  0004e	8b 0c 01	 mov	 ecx, DWORD PTR [ecx+eax]
  00051	8b 45 dc	 mov	 eax, DWORD PTR _left$1$[ebp]
  00054	89 4d f8	 mov	 DWORD PTR tv1389[ebp], ecx
  00057	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  0005a	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0005d	2b c1		 sub	 eax, ecx
  0005f	89 45 c4	 mov	 DWORD PTR tv1378[ebp], eax
$LL13@auto_vecto:
  00062	8b 3c 08	 mov	 edi, DWORD PTR [eax+ecx]
  00065	8b c6		 mov	 eax, esi
  00067	8b 55 d8	 mov	 edx, DWORD PTR tv1382[ebp]
  0006a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0006c	2b d7		 sub	 edx, edi
  0006e	89 7d f4	 mov	 DWORD PTR tv1391[ebp], edi
  00071	89 4d f0	 mov	 DWORD PTR _res_ms$1$[ebp], ecx
  00074	89 55 c8	 mov	 DWORD PTR tv1381[ebp], edx
  00077	89 75 fc	 mov	 DWORD PTR tv1393[ebp], esi
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL16@auto_vecto:
  00080	8b 34 3a	 mov	 esi, DWORD PTR [edx+edi]

; 14   : 	for (int i = 0; i < 16*Kd16; i++){

  00083	33 d2		 xor	 edx, edx

; 26   : 						loop(res[i][j][a], left[i][k][a][c], right[k][j][c], K >> 4);

  00085	f3 0f 10 0f	 movss	 xmm1, DWORD PTR [edi]

; 14   : 	for (int i = 0; i < 16*Kd16; i++){

  00089	83 fb 04	 cmp	 ebx, 4
  0008c	0f 8c 8e 00 00
	00		 jl	 $LC42@auto_vecto

; 26   : 						loop(res[i][j][a], left[i][k][a][c], right[k][j][c], K >> 4);

  00092	8b 55 f8	 mov	 edx, DWORD PTR tv1389[ebp]
  00095	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00098	89 45 d4	 mov	 DWORD PTR tv1479[ebp], eax
  0009b	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0009e	8b ce		 mov	 ecx, esi
  000a0	2b 0a		 sub	 ecx, DWORD PTR [edx]
  000a2	89 4d d0	 mov	 DWORD PTR tv1477[ebp], ecx
  000a5	8d 4b fc	 lea	 ecx, DWORD PTR [ebx-4]
  000a8	8b 5d d4	 mov	 ebx, DWORD PTR tv1479[ebp]
  000ab	8b 7d d0	 mov	 edi, DWORD PTR tv1477[ebp]
  000ae	c1 e9 02	 shr	 ecx, 2
  000b1	41		 inc	 ecx
  000b2	8d 14 8d 00 00
	00 00		 lea	 edx, DWORD PTR [ecx*4]
  000b9	0f 1f 80 00 00
	00 00		 npad	 7

; 14   : 	for (int i = 0; i < 16*Kd16; i++){

$LL43@auto_vecto:

; 15   : 		res_ms[i] += const_value * string_ms[i];

  000c0	f3 0f 10 43 f4	 movss	 xmm0, DWORD PTR [ebx-12]
  000c5	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000c9	f3 0f 58 40 fc	 addss	 xmm0, DWORD PTR [eax-4]
  000ce	f3 0f 11 40 fc	 movss	 DWORD PTR [eax-4], xmm0
  000d3	f3 0f 10 04 07	 movss	 xmm0, DWORD PTR [edi+eax]
  000d8	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000dc	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  000e0	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  000e4	f3 0f 10 43 fc	 movss	 xmm0, DWORD PTR [ebx-4]
  000e9	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000ed	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [eax+4]
  000f2	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  000f7	f3 0f 10 03	 movss	 xmm0, DWORD PTR [ebx]
  000fb	83 c3 10	 add	 ebx, 16			; 00000010H
  000fe	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00102	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  00107	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  0010c	83 c0 10	 add	 eax, 16			; 00000010H
  0010f	83 e9 01	 sub	 ecx, 1
  00112	75 ac		 jne	 SHORT $LL43@auto_vecto
  00114	8b 7d f4	 mov	 edi, DWORD PTR tv1391[ebp]
  00117	8b 5d cc	 mov	 ebx, DWORD PTR tv1380[ebp]
  0011a	8b 4d f0	 mov	 ecx, DWORD PTR _res_ms$1$[ebp]
  0011d	8b 45 fc	 mov	 eax, DWORD PTR tv1393[ebp]
$LC42@auto_vecto:

; 14   : 	for (int i = 0; i < 16*Kd16; i++){

  00120	3b d3		 cmp	 edx, ebx
  00122	7d 28		 jge	 SHORT $LN14@auto_vecto
  00124	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  00127	2b f1		 sub	 esi, ecx
  00129	8b cb		 mov	 ecx, ebx
  0012b	2b ca		 sub	 ecx, edx
  0012d	0f 1f 00	 npad	 3
$LC21@auto_vecto:

; 15   : 		res_ms[i] += const_value * string_ms[i];

  00130	f3 0f 10 04 30	 movss	 xmm0, DWORD PTR [eax+esi]
  00135	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00139	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  0013d	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00141	83 c0 04	 add	 eax, 4
  00144	83 e9 01	 sub	 ecx, 1
  00147	75 e7		 jne	 SHORT $LC21@auto_vecto
  00149	8b 45 fc	 mov	 eax, DWORD PTR tv1393[ebp]
$LN14@auto_vecto:

; 25   : 					for (int c = 0; c < K; c++)

  0014c	8b 4d f0	 mov	 ecx, DWORD PTR _res_ms$1$[ebp]
  0014f	83 c7 04	 add	 edi, 4
  00152	8b 55 c8	 mov	 edx, DWORD PTR tv1381[ebp]
  00155	83 e8 01	 sub	 eax, 1
  00158	89 7d f4	 mov	 DWORD PTR tv1391[ebp], edi
  0015b	89 45 fc	 mov	 DWORD PTR tv1393[ebp], eax
  0015e	0f 85 1c ff ff
	ff		 jne	 $LL16@auto_vecto

; 24   : 				for (int a = 0; a < K; a++)

  00164	8b 4d f8	 mov	 ecx, DWORD PTR tv1389[ebp]
  00167	8b 75 0c	 mov	 esi, DWORD PTR _K$[ebp]
  0016a	83 c1 04	 add	 ecx, 4
  0016d	83 6d ec 01	 sub	 DWORD PTR tv1390[ebp], 1
  00171	8b 45 c4	 mov	 eax, DWORD PTR tv1378[ebp]
  00174	89 4d f8	 mov	 DWORD PTR tv1389[ebp], ecx
  00177	0f 85 e5 fe ff
	ff		 jne	 $LL13@auto_vecto
  0017d	8b 55 e8	 mov	 edx, DWORD PTR tv1388[ebp]
  00180	8b 4d e4	 mov	 ecx, DWORD PTR tv1387[ebp]
  00183	8b 7d 08	 mov	 edi, DWORD PTR _res$[ebp]
  00186	8b 5d c0	 mov	 ebx, DWORD PTR _right$1$[ebp]
$LN8@auto_vecto:

; 23   : 			for (int k = 0; k < N; k++)

  00189	83 c2 04	 add	 edx, 4
  0018c	89 55 e8	 mov	 DWORD PTR tv1388[ebp], edx
  0018f	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H
  00195	0f 8c 95 fe ff
	ff		 jl	 $LL10@auto_vecto

; 22   : 		for (int j = 0; j < N; j++)

  0019b	83 c1 04	 add	 ecx, 4
  0019e	89 4d e4	 mov	 DWORD PTR tv1387[ebp], ecx
  001a1	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  001a7	0f 8c 78 fe ff
	ff		 jl	 $LL7@auto_vecto

; 21   : 	for (int i = 0; i < N; i++)

  001ad	83 c7 04	 add	 edi, 4
  001b0	83 6d e0 01	 sub	 DWORD PTR tv1386[ebp], 1
  001b4	89 7d 08	 mov	 DWORD PTR _res$[ebp], edi
  001b7	0f 85 63 fe ff
	ff		 jne	 $LL4@auto_vecto

; 27   : }

  001bd	5f		 pop	 edi
  001be	5e		 pop	 esi
  001bf	5b		 pop	 ebx
  001c0	8b e5		 mov	 esp, ebp
  001c2	5d		 pop	 ebp
  001c3	c3		 ret	 0
?auto_vectorize@@YAXPAPAPAPAM00I@Z ENDP			; auto_vectorize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
_TEXT	SEGMENT
_right$1$ = -24						; size = 4
_left$1$ = -20						; size = 4
tv690 = -16						; size = 4
_a$1$ = -12						; size = 4
tv694 = -8						; size = 4
tv696 = -4						; size = 4
_res$ = 8						; size = 4
_K$ = 12						; size = 4
?my_vectorize@@YAXPAPAPAPAM00I@Z PROC			; my_vectorize
; _left$ = ecx
; _right$ = edx

; 29   : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 18	 sub	 esp, 24			; 00000018H
  00019	56		 push	 esi

; 30   : 	for (int i = 0; i < N; i++)

  0001a	8b 73 08	 mov	 esi, DWORD PTR _res$[ebx]
  0001d	8b c1		 mov	 eax, ecx
  0001f	2b c6		 sub	 eax, esi
  00021	89 55 e8	 mov	 DWORD PTR _right$1$[ebp], edx
  00024	89 45 ec	 mov	 DWORD PTR _left$1$[ebp], eax
  00027	8b 43 0c	 mov	 eax, DWORD PTR _K$[ebx]
  0002a	57		 push	 edi
  0002b	c7 45 f0 40 00
	00 00		 mov	 DWORD PTR tv690[ebp], 64 ; 00000040H
$LL4@my_vectori:

; 31   : 		for (int j = 0; j < N; j++)

  00032	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv694[ebp], 0
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@my_vectori:

; 32   : 			for (int k = 0; k < N; k++)

  00040	33 c9		 xor	 ecx, ecx
  00042	89 4d fc	 mov	 DWORD PTR tv696[ebp], ecx
$LL10@my_vectori:

; 33   : 				for (int a = 0; a < K; a++)

  00045	33 ff		 xor	 edi, edi
  00047	89 7d f4	 mov	 DWORD PTR _a$1$[ebp], edi
  0004a	85 c0		 test	 eax, eax
  0004c	74 71		 je	 SHORT $LN8@my_vectori
  0004e	66 90		 npad	 2
$LL13@my_vectori:

; 34   : 					for (int c = 0; c < K; c++) {

  00050	33 d2		 xor	 edx, edx
$LL16@my_vectori:

; 35   : 						__m128 const_value = _mm_set1_ps(left[i][k][a][c]);

  00052	8b 45 ec	 mov	 eax, DWORD PTR _left$1$[ebp]
  00055	8b 04 30	 mov	 eax, DWORD PTR [eax+esi]
  00058	33 f6		 xor	 esi, esi
  0005a	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  0005d	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  00060	f3 0f 10 14 90	 movss	 xmm2, DWORD PTR [eax+edx*4]
  00065	0f c6 d2 00	 shufps	 xmm2, xmm2, 0
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL19@my_vectori:

; 36   : 						for (int b = 0; b < K; b += 4) {
; 37   : 							__m128 string_value = _mm_load_ps(&right[k][j][c][b]);
; 38   : 							__m128 res_value = _mm_load_ps(&res[i][j][a][b]);
; 39   : 							res_value = _mm_add_ps(res_value, _mm_mul_ps(string_value, const_value));
; 40   : 							_mm_store_ps(&res[i][j][a][b], res_value);

  00070	8b 43 08	 mov	 eax, DWORD PTR _res$[ebx]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR tv694[ebp]
  00076	8b 00		 mov	 eax, DWORD PTR [eax]
  00078	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  0007b	8b 0c b8	 mov	 ecx, DWORD PTR [eax+edi*4]
  0007e	8b 7d e8	 mov	 edi, DWORD PTR _right$1$[ebp]
  00081	8b 45 fc	 mov	 eax, DWORD PTR tv696[ebp]
  00084	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00087	8b 7d f8	 mov	 edi, DWORD PTR tv694[ebp]
  0008a	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  0008d	8b 7d f4	 mov	 edi, DWORD PTR _a$1$[ebp]
  00090	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00093	0f 10 0c b0	 movups	 xmm1, XMMWORD PTR [eax+esi*4]
  00097	8b 43 0c	 mov	 eax, DWORD PTR _K$[ebx]
  0009a	0f 59 ca	 mulps	 xmm1, xmm2
  0009d	0f 58 0c b1	 addps	 xmm1, XMMWORD PTR [ecx+esi*4]
  000a1	0f 11 0c b1	 movups	 XMMWORD PTR [ecx+esi*4], xmm1
  000a5	83 c6 04	 add	 esi, 4
  000a8	3b f0		 cmp	 esi, eax
  000aa	72 c4		 jb	 SHORT $LL19@my_vectori

; 34   : 					for (int c = 0; c < K; c++) {

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR tv696[ebp]
  000af	42		 inc	 edx
  000b0	8b 73 08	 mov	 esi, DWORD PTR _res$[ebx]
  000b3	3b d0		 cmp	 edx, eax
  000b5	72 9b		 jb	 SHORT $LL16@my_vectori

; 33   : 				for (int a = 0; a < K; a++)

  000b7	47		 inc	 edi
  000b8	89 7d f4	 mov	 DWORD PTR _a$1$[ebp], edi
  000bb	3b f8		 cmp	 edi, eax
  000bd	72 91		 jb	 SHORT $LL13@my_vectori
$LN8@my_vectori:

; 32   : 			for (int k = 0; k < N; k++)

  000bf	83 c1 04	 add	 ecx, 4
  000c2	89 4d fc	 mov	 DWORD PTR tv696[ebp], ecx
  000c5	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  000cb	0f 8c 74 ff ff
	ff		 jl	 $LL10@my_vectori

; 31   : 		for (int j = 0; j < N; j++)

  000d1	8b 55 f8	 mov	 edx, DWORD PTR tv694[ebp]
  000d4	83 c2 04	 add	 edx, 4
  000d7	89 55 f8	 mov	 DWORD PTR tv694[ebp], edx
  000da	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H
  000e0	0f 8c 5a ff ff
	ff		 jl	 $LL7@my_vectori

; 30   : 	for (int i = 0; i < N; i++)

  000e6	83 c6 04	 add	 esi, 4
  000e9	83 6d f0 01	 sub	 DWORD PTR tv690[ebp], 1
  000ed	89 73 08	 mov	 DWORD PTR _res$[ebx], esi
  000f0	0f 85 3c ff ff
	ff		 jne	 $LL4@my_vectori

; 41   : 						}
; 42   : 					}
; 43   : }

  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	8b e3		 mov	 esp, ebx
  000fd	5b		 pop	 ebx
  000fe	c3		 ret	 0
?my_vectorize@@YAXPAPAPAPAM00I@Z ENDP			; my_vectorize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
_TEXT	SEGMENT
$T1 = -24						; size = 12
tv667 = -12						; size = 4
_b$1$ = -12						; size = 4
tv664 = -8						; size = 4
_matrix$1$ = -4						; size = 4
_k$ = 8							; size = 4
_is_rand$ = 12						; size = 1
?init_matrix@@YAXAAPAPAPAPAMHH_N@Z PROC			; init_matrix
; _matrix$ = ecx
; _n$dead$ = edx

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  0000b	6a 00		 push	 0
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 46   : {

  0000d	89 7d fc	 mov	 DWORD PTR _matrix$1$[ebp], edi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp

; 47   : 	srand(time(0));

  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand

; 48   : 	matrix = (float****)_aligned_malloc(n * sizeof(float***), 16);

  0001d	6a 10		 push	 16			; 00000010H
  0001f	68 00 01 00 00	 push	 256			; 00000100H
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0002a	83 c4 10	 add	 esp, 16			; 00000010H
  0002d	89 07		 mov	 DWORD PTR [edi], eax

; 49   : 	if (!matrix) throw exception();

  0002f	85 c0		 test	 eax, eax
  00031	0f 84 da 01 00
	00		 je	 $LN27@init_matri

; 50   : 	for (int i = 0; i < n; i++) {

  00037	8b 5d 08	 mov	 ebx, DWORD PTR _k$[ebp]
  0003a	33 f6		 xor	 esi, esi
  0003c	89 75 f8	 mov	 DWORD PTR tv664[ebp], esi
  0003f	90		 npad	 1
$LL4@init_matri:

; 51   : 		matrix[i] = (float***)_aligned_malloc(n * sizeof(float**), 16);

  00040	6a 10		 push	 16			; 00000010H
  00042	68 00 01 00 00	 push	 256			; 00000100H
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0004d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0004f	83 c4 08	 add	 esp, 8
  00052	89 04 0e	 mov	 DWORD PTR [esi+ecx], eax

; 52   : 		if (!(matrix[i])) throw exception();

  00055	8b 07		 mov	 eax, DWORD PTR [edi]
  00057	83 3c 06 00	 cmp	 DWORD PTR [esi+eax], 0
  0005b	0f 84 b0 01 00
	00		 je	 $LN27@init_matri

; 53   : 		for (int j = 0; j < n; j++) {

  00061	33 ff		 xor	 edi, edi
$LL7@init_matri:

; 54   : 			matrix[i][j] = (float**)_aligned_malloc(k * sizeof(float*), 16);

  00063	33 c9		 xor	 ecx, ecx
  00065	8b c3		 mov	 eax, ebx
  00067	ba 04 00 00 00	 mov	 edx, 4
  0006c	f7 e2		 mul	 edx
  0006e	6a 10		 push	 16			; 00000010H
  00070	0f 90 c1	 seto	 cl
  00073	f7 d9		 neg	 ecx
  00075	0b c8		 or	 ecx, eax
  00077	51		 push	 ecx
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  0007e	8b 75 fc	 mov	 esi, DWORD PTR _matrix$1$[ebp]
  00081	83 c4 08	 add	 esp, 8
  00084	8b 55 f8	 mov	 edx, DWORD PTR tv664[ebp]
  00087	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00089	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  0008c	89 04 0f	 mov	 DWORD PTR [edi+ecx], eax

; 55   : 			if (!(matrix[i][j])) throw exception();

  0008f	8b 06		 mov	 eax, DWORD PTR [esi]
  00091	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00094	83 3c 07 00	 cmp	 DWORD PTR [edi+eax], 0
  00098	0f 84 73 01 00
	00		 je	 $LN27@init_matri

; 56   : 			for (int a = 0; a < k; a++) {

  0009e	33 f6		 xor	 esi, esi
  000a0	85 db		 test	 ebx, ebx
  000a2	0f 8e 3b 01 00
	00		 jle	 $LN5@init_matri
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL10@init_matri:

; 57   : 				matrix[i][j][a] = (float*)_aligned_malloc(k * sizeof(float), 16);

  000b0	33 c9		 xor	 ecx, ecx
  000b2	8b c3		 mov	 eax, ebx
  000b4	ba 04 00 00 00	 mov	 edx, 4
  000b9	f7 e2		 mul	 edx
  000bb	6a 10		 push	 16			; 00000010H
  000bd	0f 90 c1	 seto	 cl
  000c0	f7 d9		 neg	 ecx
  000c2	0b c8		 or	 ecx, eax
  000c4	51		 push	 ecx
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___aligned_malloc
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR _matrix$1$[ebp]
  000ce	83 c4 08	 add	 esp, 8
  000d1	8b 55 f8	 mov	 edx, DWORD PTR tv664[ebp]
  000d4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000d6	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  000d9	8b 0c 39	 mov	 ecx, DWORD PTR [ecx+edi]
  000dc	89 04 b1	 mov	 DWORD PTR [ecx+esi*4], eax

; 58   : 				if (!(matrix[i][j][a])) throw exception();

  000df	8b 45 fc	 mov	 eax, DWORD PTR _matrix$1$[ebp]
  000e2	8b 00		 mov	 eax, DWORD PTR [eax]
  000e4	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  000e7	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  000ea	83 3c b0 00	 cmp	 DWORD PTR [eax+esi*4], 0
  000ee	0f 84 1d 01 00
	00		 je	 $LN27@init_matri

; 60   : 					matrix[i][j][a][b] = is_rand?(double)(rand() / 100):0;

  000f4	80 7d 0c 00	 cmp	 BYTE PTR _is_rand$[ebp], 0
  000f8	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _b$1$[ebp], 0
  000ff	74 4b		 je	 SHORT $LN19@init_matri
$LL13@init_matri:
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00107	8b c8		 mov	 ecx, eax
  00109	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0010e	f7 e9		 imul	 ecx
  00110	8b 4d f4	 mov	 ecx, DWORD PTR _b$1$[ebp]
  00113	c1 fa 05	 sar	 edx, 5
  00116	8b c2		 mov	 eax, edx
  00118	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0011b	03 c2		 add	 eax, edx
  0011d	8b 55 f8	 mov	 edx, DWORD PTR tv664[ebp]
  00120	66 0f 6e c0	 movd	 xmm0, eax
  00124	8b 45 fc	 mov	 eax, DWORD PTR _matrix$1$[ebp]
  00127	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0012b	8b 00		 mov	 eax, DWORD PTR [eax]
  0012d	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00130	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00134	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00137	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0013a	f3 0f 11 04 88	 movss	 DWORD PTR [eax+ecx*4], xmm0
  0013f	41		 inc	 ecx
  00140	89 4d f4	 mov	 DWORD PTR _b$1$[ebp], ecx
  00143	3b cb		 cmp	 ecx, ebx
  00145	7c ba		 jl	 SHORT $LL13@init_matri
  00147	e9 8e 00 00 00	 jmp	 $LN8@init_matri
$LN19@init_matri:

; 59   : 				for (int b = 0; b < k; b++)

  0014c	33 c9		 xor	 ecx, ecx
  0014e	83 fb 04	 cmp	 ebx, 4
  00151	7c 63		 jl	 SHORT $LN45@init_matri
  00153	8d 43 fd	 lea	 eax, DWORD PTR [ebx-3]
  00156	8b 5d fc	 mov	 ebx, DWORD PTR _matrix$1$[ebp]
  00159	89 45 f4	 mov	 DWORD PTR tv667[ebp], eax
  0015c	0f 1f 40 00	 npad	 4
$LL44@init_matri:

; 60   : 					matrix[i][j][a][b] = is_rand?(double)(rand() / 100):0;

  00160	8b 03		 mov	 eax, DWORD PTR [ebx]
  00162	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00165	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00168	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0016b	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 0
  00172	8b 03		 mov	 eax, DWORD PTR [ebx]
  00174	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  00177	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  0017a	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  0017d	c7 44 88 04 00
	00 00 00	 mov	 DWORD PTR [eax+ecx*4+4], 0
  00185	8b 03		 mov	 eax, DWORD PTR [ebx]
  00187	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0018a	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  0018d	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00190	c7 44 88 08 00
	00 00 00	 mov	 DWORD PTR [eax+ecx*4+8], 0
  00198	8b 03		 mov	 eax, DWORD PTR [ebx]
  0019a	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0019d	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  001a0	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  001a3	c7 44 88 0c 00
	00 00 00	 mov	 DWORD PTR [eax+ecx*4+12], 0
  001ab	83 c1 04	 add	 ecx, 4
  001ae	3b 4d f4	 cmp	 ecx, DWORD PTR tv667[ebp]
  001b1	7c ad		 jl	 SHORT $LL44@init_matri
  001b3	8b 5d 08	 mov	 ebx, DWORD PTR _k$[ebp]
$LN45@init_matri:

; 59   : 				for (int b = 0; b < k; b++)

  001b6	3b cb		 cmp	 ecx, ebx
  001b8	7d 20		 jge	 SHORT $LN8@init_matri
  001ba	66 0f 1f 44 00
	00		 npad	 6
$LC34@init_matri:

; 60   : 					matrix[i][j][a][b] = is_rand?(double)(rand() / 100):0;

  001c0	8b 45 fc	 mov	 eax, DWORD PTR _matrix$1$[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  001c8	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  001cb	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  001ce	c7 04 88 00 00
	00 00		 mov	 DWORD PTR [eax+ecx*4], 0
  001d5	41		 inc	 ecx
  001d6	3b cb		 cmp	 ecx, ebx
  001d8	7c e6		 jl	 SHORT $LC34@init_matri
$LN8@init_matri:

; 56   : 			for (int a = 0; a < k; a++) {

  001da	46		 inc	 esi
  001db	3b f3		 cmp	 esi, ebx
  001dd	0f 8c cd fe ff
	ff		 jl	 $LL10@init_matri
$LN5@init_matri:

; 53   : 		for (int j = 0; j < n; j++) {

  001e3	83 c7 04	 add	 edi, 4
  001e6	81 ff 00 01 00
	00		 cmp	 edi, 256		; 00000100H
  001ec	0f 8c 71 fe ff
	ff		 jl	 $LL7@init_matri

; 50   : 	for (int i = 0; i < n; i++) {

  001f2	83 c2 04	 add	 edx, 4
  001f5	89 55 f8	 mov	 DWORD PTR tv664[ebp], edx
  001f8	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H
  001fe	7d 0a		 jge	 SHORT $LN53@init_matri
  00200	8b 7d fc	 mov	 edi, DWORD PTR _matrix$1$[ebp]
  00203	8b f2		 mov	 esi, edx
  00205	e9 36 fe ff ff	 jmp	 $LL4@init_matri
$LN53@init_matri:
  0020a	5f		 pop	 edi

; 52   : 		if (!(matrix[i])) throw exception();

  0020b	5e		 pop	 esi
  0020c	5b		 pop	 ebx

; 61   : 			}
; 62   : 		}
; 63   : 	}
; 64   : }

  0020d	8b e5		 mov	 esp, ebp
  0020f	5d		 pop	 ebp
  00210	c3		 ret	 0
$LN27@init_matri:
  00211	8d 4d e8	 lea	 ecx, DWORD PTR $T1[ebp]
  00214	e8 00 00 00 00	 call	 ??0exception@std@@QAE@XZ ; std::exception::exception
  00219	68 00 00 00 00	 push	 OFFSET __TI1?AVexception@std@@
  0021e	8b c1		 mov	 eax, ecx
  00220	50		 push	 eax
  00221	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN56@init_matri:
  00226	cc		 int	 3
?init_matrix@@YAXAAPAPAPAPAMHH_N@Z ENDP			; init_matrix
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\UNIVER\6 sem\AWP\Lab1\Lab1\Source.cpp
_TEXT	SEGMENT
tv1166 = -60						; size = 4
tv1161 = -60						; size = 4
tv1169 = -56						; size = 4
tv1159 = -56						; size = 4
_matrix$1$ = -52					; size = 4
tv1165 = -48						; size = 4
_b$1$ = -48						; size = 4
tv1186 = -44						; size = 4
tv1156 = -44						; size = 4
_c$1$ = -40						; size = 4
_K$1$ = -36						; size = 4
_start$2$ = -36						; size = 4
_K$1$ = -32						; size = 4
_start$1$ = -32						; size = 4
tv1185 = -28						; size = 4
tv1164 = -24						; size = 4
_K$1 = -20						; size = 4
_matrix$2 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_main	PROC

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 40	 sub	 esp, 64			; 00000040H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 3c	 mov	 DWORD PTR __$ArrayPad$[esp+64], eax

; 68   : 	while (1) {
; 69   : 		unsigned int K;
; 70   : 		cout << "input contains matrix size: ";

  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0001a	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@MGAFAJLF@input?5contains?5matrix?5size?3?5@
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 71   : 		cin >> K;

  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  0002c	8d 44 24 34	 lea	 eax, DWORD PTR _K$1[esp+72]
  00030	50		 push	 eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAI@Z

; 72   : 		if (K % 16) return 1;

  00037	8b 4c 24 34	 mov	 ecx, DWORD PTR _K$1[esp+72]
  0003b	f6 c1 0f	 test	 cl, 15			; 0000000fH
  0003e	0f 85 ed 02 00
	00		 jne	 $LN100@main
$LL2@main:

; 73   : 		float**** matrix[3];
; 74   : 		for (int i = 0; i < 3; i++)

  00044	33 f6		 xor	 esi, esi
  00046	8d 7c 24 38	 lea	 edi, DWORD PTR _matrix$2[esp+72]
  0004a	66 0f 1f 44 00
	00		 npad	 6
$LL6@main:

; 75   : 			init_matrix(matrix[i], N, K, i != 2);

  00050	83 fe 02	 cmp	 esi, 2
  00053	0f 95 c0	 setne	 al
  00056	0f b6 c0	 movzx	 eax, al
  00059	50		 push	 eax
  0005a	51		 push	 ecx
  0005b	8b cf		 mov	 ecx, edi
  0005d	e8 00 00 00 00	 call	 ?init_matrix@@YAXAAPAPAPAPAMHH_N@Z ; init_matrix
  00062	46		 inc	 esi
  00063	83 c4 08	 add	 esp, 8
  00066	83 c7 04	 add	 edi, 4
  00069	83 fe 03	 cmp	 esi, 3
  0006c	7d 06		 jge	 SHORT $LN115@main

; 73   : 		float**** matrix[3];
; 74   : 		for (int i = 0; i < 3; i++)

  0006e	8b 4c 24 34	 mov	 ecx, DWORD PTR _K$1[esp+72]
  00072	eb dc		 jmp	 SHORT $LL6@main
$LN115@main:

; 76   : 		DWORD start = GetTickCount64();

  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount64@0
  0007a	8b 54 24 38	 mov	 edx, DWORD PTR _matrix$2[esp+72]

; 77   : 		auto_vectorize(matrix[0], matrix[1], matrix[2], K);

  0007e	8b 4c 24 34	 mov	 ecx, DWORD PTR _K$1[esp+72]
  00082	89 44 24 28	 mov	 DWORD PTR _start$1$[esp+72], eax
  00086	8b 44 24 40	 mov	 eax, DWORD PTR _matrix$2[esp+80]
  0008a	2b d0		 sub	 edx, eax
  0008c	89 4c 24 24	 mov	 DWORD PTR _K$1$[esp+72], ecx
  00090	89 44 24 14	 mov	 DWORD PTR _matrix$1$[esp+72], eax
  00094	89 44 24 18	 mov	 DWORD PTR tv1165[esp+72], eax
  00098	89 54 24 30	 mov	 DWORD PTR tv1164[esp+72], edx
  0009c	c7 44 24 1c 40
	00 00 00	 mov	 DWORD PTR tv1186[esp+72], 64 ; 00000040H
$LL12@main:

; 22   : 		for (int j = 0; j < N; j++)

  000a4	33 d2		 xor	 edx, edx
  000a6	89 54 24 0c	 mov	 DWORD PTR tv1166[esp+72], edx
  000aa	66 0f 1f 44 00
	00		 npad	 6
$LL15@main:

; 23   : 			for (int k = 0; k < N; k++)

  000b0	33 f6		 xor	 esi, esi
  000b2	89 74 24 10	 mov	 DWORD PTR tv1169[esp+72], esi
$LL18@main:

; 24   : 				for (int a = 0; a < K; a++)

  000b6	33 ff		 xor	 edi, edi
  000b8	85 c9		 test	 ecx, ecx
  000ba	0f 84 7e 00 00
	00		 je	 $LN16@main
  000c0	8b c1		 mov	 eax, ecx
  000c2	c1 e8 04	 shr	 eax, 4
  000c5	89 44 24 2c	 mov	 DWORD PTR tv1185[esp+72], eax
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL21@main:

; 25   : 					for (int c = 0; c < K; c++)

  000d0	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _c$1$[esp+72], 0
  000d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL24@main:

; 26   : 						loop(res[i][j][a], left[i][k][a][c], right[k][j][c], K >> 4);

  000e0	8b 4c 24 18	 mov	 ecx, DWORD PTR tv1165[esp+72]
  000e4	50		 push	 eax
  000e5	8b 44 24 40	 mov	 eax, DWORD PTR _matrix$2[esp+80]
  000e9	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  000ec	8b 14 02	 mov	 edx, DWORD PTR [edx+eax]
  000ef	8b 44 24 34	 mov	 eax, DWORD PTR tv1164[esp+76]
  000f3	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  000f6	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  000f9	8b 34 b8	 mov	 esi, DWORD PTR [eax+edi*4]
  000fc	8b 01		 mov	 eax, DWORD PTR [ecx]
  000fe	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1166[esp+76]
  00102	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00105	8b 44 24 24	 mov	 eax, DWORD PTR _c$1$[esp+76]
  00109	8b 0c b9	 mov	 ecx, DWORD PTR [ecx+edi*4]
  0010c	8b 14 82	 mov	 edx, DWORD PTR [edx+eax*4]
  0010f	f3 0f 10 0c 86	 movss	 xmm1, DWORD PTR [esi+eax*4]
  00114	e8 00 00 00 00	 call	 ?loop@@YAXPAMM0H@Z	; loop
  00119	8b 44 24 24	 mov	 eax, DWORD PTR _c$1$[esp+76]
  0011d	83 c4 04	 add	 esp, 4
  00120	8b 4c 24 24	 mov	 ecx, DWORD PTR _K$1$[esp+72]
  00124	40		 inc	 eax
  00125	8b 74 24 10	 mov	 esi, DWORD PTR tv1169[esp+72]
  00129	3b c1		 cmp	 eax, ecx
  0012b	8b 54 24 0c	 mov	 edx, DWORD PTR tv1166[esp+72]
  0012f	89 44 24 20	 mov	 DWORD PTR _c$1$[esp+72], eax
  00133	8b 44 24 2c	 mov	 eax, DWORD PTR tv1185[esp+72]
  00137	72 a7		 jb	 SHORT $LL24@main

; 24   : 				for (int a = 0; a < K; a++)

  00139	47		 inc	 edi
  0013a	3b f9		 cmp	 edi, ecx
  0013c	72 92		 jb	 SHORT $LL21@main
$LN16@main:

; 23   : 			for (int k = 0; k < N; k++)

  0013e	83 c6 04	 add	 esi, 4
  00141	89 74 24 10	 mov	 DWORD PTR tv1169[esp+72], esi
  00145	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  0014b	0f 8c 65 ff ff
	ff		 jl	 $LL18@main

; 22   : 		for (int j = 0; j < N; j++)

  00151	83 c2 04	 add	 edx, 4
  00154	89 54 24 0c	 mov	 DWORD PTR tv1166[esp+72], edx
  00158	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H
  0015e	0f 8c 4c ff ff
	ff		 jl	 $LL15@main

; 21   : 	for (int i = 0; i < N; i++)

  00164	83 44 24 18 04	 add	 DWORD PTR tv1165[esp+72], 4
  00169	83 6c 24 1c 01	 sub	 DWORD PTR tv1186[esp+72], 1
  0016e	0f 85 30 ff ff
	ff		 jne	 $LL12@main

; 78   : 		DWORD duration = GetTickCount64() - start;

  00174	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetTickCount64@0
  0017a	ff d6		 call	 esi
  0017c	2b 44 24 28	 sub	 eax, DWORD PTR _start$1$[esp+72]

; 79   : 		cout << "auto_vec: " << duration << " ticks" << endl;

  00180	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0L@HNBJPKEP@auto_vec?3?5@
  00185	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0018a	50		 push	 eax
  0018b	51		 push	 ecx
  0018c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00192	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00197	83 c4 04	 add	 esp, 4
  0019a	8b c8		 mov	 ecx, eax
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
  001a2	51		 push	 ecx
  001a3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06MALMBFOP@?5ticks@
  001a8	8b c8		 mov	 ecx, eax
  001aa	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001af	83 c4 04	 add	 esp, 4
  001b2	8b c8		 mov	 ecx, eax
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 80   : 		start = GetTickCount64();

  001ba	ff d6		 call	 esi

; 81   : 		my_vectorize(matrix[0], matrix[1], matrix[2], K);

  001bc	8b 7c 24 34	 mov	 edi, DWORD PTR _K$1[esp+72]
  001c0	89 44 24 24	 mov	 DWORD PTR _start$2$[esp+72], eax
  001c4	8b 44 24 14	 mov	 eax, DWORD PTR _matrix$1$[esp+72]
  001c8	89 7c 24 28	 mov	 DWORD PTR _K$1$[esp+72], edi
  001cc	c7 44 24 1c 40
	00 00 00	 mov	 DWORD PTR tv1156[esp+72], 64 ; 00000040H
$LL29@main:

; 31   : 		for (int j = 0; j < N; j++)

  001d4	33 c9		 xor	 ecx, ecx
  001d6	89 4c 24 10	 mov	 DWORD PTR tv1159[esp+72], ecx
  001da	66 0f 1f 44 00
	00		 npad	 6
$LL32@main:

; 32   : 			for (int k = 0; k < N; k++)

  001e0	33 c9		 xor	 ecx, ecx
  001e2	89 4c 24 0c	 mov	 DWORD PTR tv1161[esp+72], ecx
$LL35@main:

; 33   : 				for (int a = 0; a < K; a++)

  001e6	33 f6		 xor	 esi, esi
  001e8	85 ff		 test	 edi, edi
  001ea	0f 84 8f 00 00
	00		 je	 $LN33@main
$LL38@main:

; 34   : 					for (int c = 0; c < K; c++) {

  001f0	33 d2		 xor	 edx, edx
  001f2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL41@main:

; 35   : 						__m128 const_value = _mm_set1_ps(left[i][k][a][c]);

  00200	8b 7c 24 30	 mov	 edi, DWORD PTR tv1164[esp+72]
  00204	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _b$1$[esp+72], 0
  0020c	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  0020f	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00212	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00215	f3 0f 10 14 90	 movss	 xmm2, DWORD PTR [eax+edx*4]
  0021a	0f c6 d2 00	 shufps	 xmm2, xmm2, 0
  0021e	66 90		 npad	 2
$LL44@main:

; 36   : 						for (int b = 0; b < K; b += 4) {
; 37   : 							__m128 string_value = _mm_load_ps(&right[k][j][c][b]);
; 38   : 							__m128 res_value = _mm_load_ps(&res[i][j][a][b]);
; 39   : 							res_value = _mm_add_ps(res_value, _mm_mul_ps(string_value, const_value));
; 40   : 							_mm_store_ps(&res[i][j][a][b], res_value);

  00220	8b 44 24 14	 mov	 eax, DWORD PTR _matrix$1$[esp+72]
  00224	8b 7c 24 10	 mov	 edi, DWORD PTR tv1159[esp+72]
  00228	8b 00		 mov	 eax, DWORD PTR [eax]
  0022a	8b 04 07	 mov	 eax, DWORD PTR [edi+eax]
  0022d	8b 7c 24 3c	 mov	 edi, DWORD PTR _matrix$2[esp+76]
  00231	8b 0c b0	 mov	 ecx, DWORD PTR [eax+esi*4]
  00234	8b 44 24 0c	 mov	 eax, DWORD PTR tv1161[esp+72]
  00238	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  0023b	8b 7c 24 10	 mov	 edi, DWORD PTR tv1159[esp+72]
  0023f	8b 04 38	 mov	 eax, DWORD PTR [eax+edi]
  00242	8b 7c 24 18	 mov	 edi, DWORD PTR _b$1$[esp+72]
  00246	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00249	0f 10 0c b8	 movups	 xmm1, XMMWORD PTR [eax+edi*4]
  0024d	8b c7		 mov	 eax, edi
  0024f	8b 7c 24 28	 mov	 edi, DWORD PTR _K$1$[esp+72]
  00253	0f 59 ca	 mulps	 xmm1, xmm2
  00256	0f 58 0c 81	 addps	 xmm1, XMMWORD PTR [ecx+eax*4]
  0025a	0f 11 0c 81	 movups	 XMMWORD PTR [ecx+eax*4], xmm1
  0025e	83 c0 04	 add	 eax, 4
  00261	89 44 24 18	 mov	 DWORD PTR _b$1$[esp+72], eax
  00265	3b c7		 cmp	 eax, edi
  00267	72 b7		 jb	 SHORT $LL44@main

; 34   : 					for (int c = 0; c < K; c++) {

  00269	8b 4c 24 0c	 mov	 ecx, DWORD PTR tv1161[esp+72]
  0026d	42		 inc	 edx
  0026e	8b 44 24 14	 mov	 eax, DWORD PTR _matrix$1$[esp+72]
  00272	3b d7		 cmp	 edx, edi
  00274	72 8a		 jb	 SHORT $LL41@main

; 33   : 				for (int a = 0; a < K; a++)

  00276	46		 inc	 esi
  00277	3b f7		 cmp	 esi, edi
  00279	0f 82 71 ff ff
	ff		 jb	 $LL38@main
$LN33@main:

; 32   : 			for (int k = 0; k < N; k++)

  0027f	8b 44 24 14	 mov	 eax, DWORD PTR _matrix$1$[esp+72]
  00283	83 c1 04	 add	 ecx, 4
  00286	89 4c 24 0c	 mov	 DWORD PTR tv1161[esp+72], ecx
  0028a	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00290	0f 8c 50 ff ff
	ff		 jl	 $LL35@main

; 31   : 		for (int j = 0; j < N; j++)

  00296	8b 4c 24 10	 mov	 ecx, DWORD PTR tv1159[esp+72]
  0029a	83 c1 04	 add	 ecx, 4
  0029d	89 4c 24 10	 mov	 DWORD PTR tv1159[esp+72], ecx
  002a1	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  002a7	0f 8c 33 ff ff
	ff		 jl	 $LL32@main

; 27   : }
; 28   : void my_vectorize(float**** left, float**** right, float**** res, unsigned K)
; 29   : {
; 30   : 	for (int i = 0; i < N; i++)

  002ad	83 c0 04	 add	 eax, 4
  002b0	83 6c 24 1c 01	 sub	 DWORD PTR tv1156[esp+72], 1
  002b5	89 44 24 14	 mov	 DWORD PTR _matrix$1$[esp+72], eax
  002b9	0f 85 15 ff ff
	ff		 jne	 $LL29@main

; 82   : 		duration = GetTickCount64() - start;

  002bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount64@0
  002c5	2b 44 24 24	 sub	 eax, DWORD PTR _start$2$[esp+72]

; 83   : 		cout << "my_vec: " << duration << " ticks" << endl;

  002c9	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_08MLBKJEKP@my_vec?3?5@
  002ce	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002d3	50		 push	 eax
  002d4	51		 push	 ecx
  002d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002db	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002e0	83 c4 04	 add	 esp, 4
  002e3	8b c8		 mov	 ecx, eax
  002e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@K@Z
  002eb	51		 push	 ecx
  002ec	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_06MALMBFOP@?5ticks@
  002f1	8b c8		 mov	 ecx, eax
  002f3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002f8	83 c4 04	 add	 esp, 4
  002fb	8b c8		 mov	 ecx, eax
  002fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00303	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00309	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_0BN@MGAFAJLF@input?5contains?5matrix?5size?3?5@
  0030e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00313	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  00319	8d 44 24 34	 lea	 eax, DWORD PTR _K$1[esp+72]
  0031d	50		 push	 eax
  0031e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAI@Z
  00324	8b 4c 24 34	 mov	 ecx, DWORD PTR _K$1[esp+72]
  00328	f6 c1 0f	 test	 cl, 15			; 0000000fH
  0032b	0f 84 13 fd ff
	ff		 je	 $LL2@main
$LN100@main:

; 84   : 	}
; 85   : 	system("pause > NUL");
; 86   : 	return 0;
; 87   : }

  00331	8b 4c 24 44	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+72]
  00335	b8 01 00 00 00	 mov	 eax, 1
  0033a	5f		 pop	 edi
  0033b	5e		 pop	 esi
  0033c	33 cc		 xor	 ecx, esp
  0033e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00343	8b e5		 mov	 esp, ebp
  00345	5d		 pop	 ebp
  00346	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 131  :             return _Ok;

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 132  :         }

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 115  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 116  : #if _HAS_EXCEPTIONS
; 117  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  0002b	84 c0		 test	 al, al
  0002d	75 08		 jne	 SHORT $LN2@sentry

; 118  :                 this->_Myostr._Osfx();

  0002f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  0003e	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 78   :             if (_Rdbuf) {

  00049	85 c9		 test	 ecx, ecx
  0004b	74 05		 je	 SHORT $LN5@sentry

; 79   :                 _Rdbuf->_Unlock();

  0004d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004f	ff 50 08	 call	 DWORD PTR [eax+8]
$LN5@sentry:

; 119  :             }
; 120  : #else // _HAS_EXCEPTIONS
; 121  :             this->_Myostr._Osfx();
; 122  : #endif // _HAS_EXCEPTIONS
; 123  :         }

  00052	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005c	59		 pop	 ecx
  0005d	5e		 pop	 esi
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 90   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f1		 mov	 esi, ecx
  00027	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002a	8b 7d 08	 mov	 edi, DWORD PTR __Ostr$[ebp]

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  0002d	89 3e		 mov	 DWORD PTR [esi], edi

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();

  0002f	8b 17		 mov	 edx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  00031	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00034	8b 4c 38 38	 mov	 ecx, DWORD PTR [eax+edi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 71   :             if (_Rdbuf) {

  00038	85 c9		 test	 ecx, ecx
  0003a	74 07		 je	 SHORT $LN8@sentry

; 72   :                 _Rdbuf->_Lock();

  0003c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003e	ff 50 04	 call	 DWORD PTR [eax+4]
  00041	8b 17		 mov	 edx, DWORD PTR [edi]
$LN8@sentry:

; 91   :             : _Sentry_base(_Ostr) { // construct locking and testing stream

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 276  :         return _Mystate;

  0004a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 295  :         return rdstate() == ios_base::goodbit;

  0004d	83 7c 38 0c 00	 cmp	 DWORD PTR [eax+edi+12], 0

; 276  :         return _Mystate;

  00052	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 92   :             if (!_Ostr.good()) {

  00055	74 04		 je	 SHORT $LN2@sentry

; 93   :                 _Ok = false;

  00057	32 c0		 xor	 al, al

; 94   :                 return;

  00059	eb 22		 jmp	 SHORT $LN23@sentry
$LN2@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 66   :         return _Tiestr;

  0005b	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

  0005e	85 c9		 test	 ecx, ecx
  00060	74 19		 je	 SHORT $LN4@sentry
  00062	3b cf		 cmp	 ecx, edi
  00064	74 15		 je	 SHORT $LN4@sentry

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  : 
; 104  :             _Tied->flush();

  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 295  :         return rdstate() == ios_base::goodbit;

  0006c	8b 07		 mov	 eax, DWORD PTR [edi]
  0006e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00071	83 7c 38 0c 00	 cmp	 DWORD PTR [eax+edi+12], 0
  00076	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  00079	eb 02		 jmp	 SHORT $LN23@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

  0007b	b0 01		 mov	 al, 1
$LN23@sentry:

; 106  :         }

  0007d	88 46 04	 mov	 BYTE PTR [esi+4], al
  00080	8b c6		 mov	 eax, esi
  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 411  :         return static_cast<int_type>(EOF);

  00000	83 c8 ff	 or	 eax, -1

; 412  :     }

  00003	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 402  :         // test for metacharacter equality
; 403  :         return _Left == _Right;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	3b 02		 cmp	 eax, DWORD PTR [edx]
  00004	0f 94 c0	 sete	 al

; 404  :     }

  00007	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT
; __First$ = ecx

; 311  :         // find length of null-terminated string
; 312  : #if _HAS_CXX17
; 313  : #if _HAS_CHAR8_T
; 314  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 315  : #if _HAS_U8_INTRINSICS
; 316  :             return __builtin_u8strlen(_First);
; 317  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 318  :             return _Char_traits<_Elem, _Int_type>::length(_First);
; 319  : #endif // _HAS_U8_INTRINSICS
; 320  :         } else
; 321  : #endif // _HAS_CHAR8_T
; 322  :         {
; 323  :             return __builtin_strlen(_First);
; 324  :         }
; 325  : #else // _HAS_CXX17
; 326  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00000	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL3@length:
  00003	8a 01		 mov	 al, BYTE PTR [ecx]
  00005	41		 inc	 ecx
  00006	84 c0		 test	 al, al
  00008	75 f9		 jne	 SHORT $LL3@length
  0000a	2b ca		 sub	 ecx, edx
  0000c	8b c1		 mov	 eax, ecx

; 327  : #endif // _HAS_CXX17
; 328  :     }

  0000e	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 77   :             const auto _Rdbuf = _Myostr.rdbuf();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00029	8b 4c 08 38	 mov	 ecx, DWORD PTR [eax+ecx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 78   :             if (_Rdbuf) {

  0002d	85 c9		 test	 ecx, ecx
  0002f	74 05		 je	 SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Unlock();

  00031	8b 01		 mov	 eax, DWORD PTR [ecx]
  00033	ff 50 08	 call	 DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 16		 mov	 DWORD PTR [esi], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  0000b	8b 02		 mov	 eax, DWORD PTR [edx]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4c 10 38	 mov	 ecx, DWORD PTR [eax+edx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 71   :             if (_Rdbuf) {

  00014	85 c9		 test	 ecx, ecx
  00016	74 05		 je	 SHORT $LN6@Sentry_bas

; 72   :                 _Rdbuf->_Lock();

  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN6@Sentry_bas:

; 73   :             }
; 74   :         }

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
__Pad$ = -48						; size = 8
__State$ = -36						; size = 4
__Val$1$ = -32						; size = 4
$T2 = -32						; size = 1
tv668 = -28						; size = 4
$T3 = -28						; size = 1
__Ostr$ = -24						; size = 4
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 738  :     const char* _Val) { // insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b c2		 mov	 eax, edx
  0002d	89 45 e0	 mov	 DWORD PTR __Val$1$[ebp], eax
  00030	8b d9		 mov	 ebx, ecx
  00032	89 5d e8	 mov	 DWORD PTR __Ostr$[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring

; 326  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00035	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 742  :     ios_base::iostate _State = ios_base::goodbit;

  00037	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring

; 326  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0003e	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL93@operator:
  00041	8a 01		 mov	 al, BYTE PTR [ecx]
  00043	41		 inc	 ecx
  00044	84 c0		 test	 al, al
  00046	75 f9		 jne	 SHORT $LL93@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 744  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00048	8b 13		 mov	 edx, DWORD PTR [ebx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xstring

; 326  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0004a	2b ce		 sub	 ecx, esi
  0004c	89 4d ec	 mov	 DWORD PTR __Count$2$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 363  :         return _Wide;

  0004f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00052	03 c3		 add	 eax, ebx
  00054	89 45 e4	 mov	 DWORD PTR tv668[ebp], eax
  00057	8b 78 24	 mov	 edi, DWORD PTR [eax+36]
  0005a	8b 70 20	 mov	 esi, DWORD PTR [eax+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 744  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  0005d	85 ff		 test	 edi, edi
  0005f	7c 17		 jl	 SHORT $LN17@operator
  00061	7f 0e		 jg	 SHORT $LN95@operator
  00063	85 f6		 test	 esi, esi
  00065	74 11		 je	 SHORT $LN17@operator
  00067	85 ff		 test	 edi, edi
  00069	7c 0d		 jl	 SHORT $LN17@operator
  0006b	7f 04		 jg	 SHORT $LN95@operator
  0006d	3b f1		 cmp	 esi, ecx
  0006f	76 07		 jbe	 SHORT $LN17@operator
$LN95@operator:
  00071	2b f1		 sub	 esi, ecx
  00073	83 df 00	 sbb	 edi, 0
  00076	eb 0e		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00078	0f 57 c0	 xorps	 xmm0, xmm0
  0007b	66 0f 13 45 d0	 movlpd	 QWORD PTR __Pad$[ebp], xmm0
  00080	8b 7d d4	 mov	 edi, DWORD PTR __Pad$[ebp+4]
  00083	8b 75 d0	 mov	 esi, DWORD PTR __Pad$[ebp]
$LN18@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  00086	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00089	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  0008b	89 5d d0	 mov	 DWORD PTR __Ok$[ebp], ebx

; 70   :             const auto _Rdbuf = _Myostr.rdbuf();
; 71   :             if (_Rdbuf) {

  0008e	85 c0		 test	 eax, eax
  00090	74 0f		 je	 SHORT $LN39@operator

; 72   :                 _Rdbuf->_Lock();

  00092	8b 4d e4	 mov	 ecx, DWORD PTR tv668[ebp]
  00095	8b 00		 mov	 eax, DWORD PTR [eax]
  00097	8b 49 38	 mov	 ecx, DWORD PTR [ecx+56]
  0009a	ff 50 04	 call	 DWORD PTR [eax+4]
  0009d	8b 13		 mov	 edx, DWORD PTR [ebx]
  0009f	8b ca		 mov	 ecx, edx
$LN39@operator:

; 91   :             : _Sentry_base(_Ostr) { // construct locking and testing stream

  000a1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 276  :         return _Mystate;

  000a8	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000ab	03 c3		 add	 eax, ebx

; 295  :         return rdstate() == ios_base::goodbit;

  000ad	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 92   :             if (!_Ostr.good()) {

  000b1	74 04		 je	 SHORT $LN33@operator

; 93   :                 _Ok = false;

  000b3	32 c0		 xor	 al, al

; 94   :                 return;

  000b5	eb 26		 jmp	 SHORT $LN108@operator
$LN33@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 66   :         return _Tiestr;

  000b7	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 98   :             if (!_Tied || _Tied == &_Ostr) {

  000ba	85 c0		 test	 eax, eax
  000bc	74 1d		 je	 SHORT $LN35@operator
  000be	3b c3		 cmp	 eax, ebx
  000c0	74 19		 je	 SHORT $LN35@operator

; 100  :                 return;
; 101  :             }
; 102  : 
; 103  : 
; 104  :             _Tied->flush();

  000c2	8b c8		 mov	 ecx, eax
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000ca	8b 13		 mov	 edx, DWORD PTR [ebx]
  000cc	8b ca		 mov	 ecx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 276  :         return _Mystate;

  000ce	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 295  :         return rdstate() == ios_base::goodbit;

  000d1	83 7c 18 0c 00	 cmp	 DWORD PTR [eax+ebx+12], 0
  000d6	0f 94 c0	 sete	 al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000d9	eb 02		 jmp	 SHORT $LN108@operator
$LN35@operator:

; 99   :                 _Ok = true;

  000db	b0 01		 mov	 al, 1
$LN108@operator:

; 745  :     const typename _Myos::sentry _Ok(_Ostr);

  000dd	88 45 d4	 mov	 BYTE PTR __Ok$[ebp+4], al
  000e0	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 746  : 
; 747  :     if (!_Ok) {

  000e7	84 c0		 test	 al, al
  000e9	75 0a		 jne	 SHORT $LN8@operator

; 748  :         _State |= ios_base::badbit;

  000eb	b9 04 00 00 00	 mov	 ecx, 4

; 749  :     } else { // state okay, insert

  000f0	e9 e7 00 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 750  :         _TRY_IO_BEGIN

  000f5	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 326  :         return _Fmtfl;

  000f9	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000fc	8b 44 18 14	 mov	 eax, DWORD PTR [eax+ebx+20]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 751  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  00100	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00105	83 f8 40	 cmp	 eax, 64			; 00000040H
  00108	74 3d		 je	 SHORT $LN89@operator
  0010a	66 0f 1f 44 00
	00		 npad	 6
$LL4@operator:

; 752  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00110	85 ff		 test	 edi, edi
  00112	7c 31		 jl	 SHORT $LN3@operator
  00114	7f 04		 jg	 SHORT $LN96@operator
  00116	85 f6		 test	 esi, esi
  00118	74 2b		 je	 SHORT $LN3@operator
$LN96@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 97   :         return _Fillch;

  0011a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0011c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0011f	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 753  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00123	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 97   :         return _Fillch;

  00127	88 45 e4	 mov	 BYTE PTR $T3[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 753  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0012a	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00133	83 f8 ff	 cmp	 eax, -1
  00136	75 05		 jne	 SHORT $LN2@operator

; 754  :                     _State |= ios_base::badbit; // insertion failed, quit

  00138	8d 48 05	 lea	 ecx, DWORD PTR [eax+5]

; 755  :                     break;

  0013b	eb 61		 jmp	 SHORT $LN6@operator
$LN2@operator:

; 752  :             for (; 0 < _Pad; --_Pad) { // pad on left

  0013d	83 c6 ff	 add	 esi, -1
  00140	83 d7 ff	 adc	 edi, -1
  00143	eb cb		 jmp	 SHORT $LL4@operator
$LN3@operator:

; 760  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00145	8b 0b		 mov	 ecx, DWORD PTR [ebx]
$LN89@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  00147	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 760  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0014a	6a 00		 push	 0
  0014c	ff 75 ec	 push	 DWORD PTR __Count$2$[ebp]
  0014f	ff 75 e0	 push	 DWORD PTR __Val$1$[ebp]
  00152	8b 4c 18 38	 mov	 ecx, DWORD PTR [eax+ebx+56]
  00156	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  0015c	3b 45 ec	 cmp	 eax, DWORD PTR __Count$2$[ebp]
  0015f	75 2c		 jne	 SHORT $LN97@operator
  00161	85 d2		 test	 edx, edx
  00163	75 28		 jne	 SHORT $LN97@operator
$LL99@operator:

; 761  :             _State |= ios_base::badbit;
; 762  :         }
; 763  : 
; 764  :         if (_State == ios_base::goodbit) {
; 765  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00165	85 ff		 test	 edi, edi
  00167	7c 33		 jl	 SHORT $LN103@operator
  00169	7f 04		 jg	 SHORT $LN98@operator
  0016b	85 f6		 test	 esi, esi
  0016d	74 2d		 je	 SHORT $LN103@operator
$LN98@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 97   :         return _Fillch;

  0016f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00171	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00174	8a 44 19 40	 mov	 al, BYTE PTR [ecx+ebx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 766  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00178	8b 4c 19 38	 mov	 ecx, DWORD PTR [ecx+ebx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 97   :         return _Fillch;

  0017c	88 45 e0	 mov	 BYTE PTR $T2[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 766  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0017f	ff 75 e0	 push	 DWORD PTR $T2[ebp]
  00182	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00188	83 f8 ff	 cmp	 eax, -1
  0018b	75 07		 jne	 SHORT $LN5@operator
$LN97@operator:

; 767  :                     _State |= ios_base::badbit; // insertion failed, quit
; 768  :                     break;
; 769  :                 }
; 770  :             }
; 771  :         }
; 772  : 
; 773  :         _Ostr.width(0);

  0018d	b9 04 00 00 00	 mov	 ecx, 4
  00192	eb 0a		 jmp	 SHORT $LN6@operator
$LN5@operator:

; 761  :             _State |= ios_base::badbit;
; 762  :         }
; 763  : 
; 764  :         if (_State == ios_base::goodbit) {
; 765  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00194	83 c6 ff	 add	 esi, -1
  00197	83 d7 ff	 adc	 edi, -1
  0019a	eb c9		 jmp	 SHORT $LL99@operator
$LN103@operator:

; 767  :                     _State |= ios_base::badbit; // insertion failed, quit
; 768  :                     break;
; 769  :                 }
; 770  :             }
; 771  :         }
; 772  : 
; 773  :         _Ostr.width(0);

  0019c	33 c9		 xor	 ecx, ecx
$LN6@operator:
  0019e	8b 03		 mov	 eax, DWORD PTR [ebx]
  001a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\xiosbase

; 368  :         _Wide                      = _Newwidth;

  001a3	c7 44 18 20 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+32], 0
  001ab	c7 44 18 24 00
	00 00 00	 mov	 DWORD PTR [eax+ebx+36], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
  001b3	eb 20		 jmp	 SHORT $LN109@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 774  :         _CATCH_IO_(ios_base, _Ostr)

  001b5	8b 55 e8	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001b8	6a 01		 push	 1
  001ba	6a 04		 push	 4
  001bc	8b 02		 mov	 eax, DWORD PTR [edx]
  001be	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001c1	03 ca		 add	 ecx, edx
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  001c9	b8 00 00 00 00	 mov	 eax, $LN23@operator
  001ce	c3		 ret	 0
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios
  001cf	8b 5d e8	 mov	 ebx, DWORD PTR __Ostr$[ebp]
  001d2	8b 4d dc	 mov	 ecx, DWORD PTR __State$[ebp]
$LN109@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 775  :     }
; 776  : 
; 777  :     _Ostr.setstate(_State);

  001d5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
  001dc	8b 03		 mov	 eax, DWORD PTR [ebx]
  001de	6a 00		 push	 0
  001e0	51		 push	 ecx
  001e1	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001e4	03 cb		 add	 ecx, ebx
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 115  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  001ec	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 4

; 116  : #if _HAS_EXCEPTIONS
; 117  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

  001f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  001f9	8b 75 d0	 mov	 esi, DWORD PTR __Ok$[ebp]
  001fc	84 c0		 test	 al, al
  001fe	75 08		 jne	 SHORT $LN74@operator

; 118  :                 this->_Myostr._Osfx();

  00200	8b ce		 mov	 ecx, esi
  00202	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN74@operator:

; 76   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00208	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+12], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ios

; 76   :         return _Mystrbuf;

  0020c	8b 06		 mov	 eax, DWORD PTR [esi]
  0020e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00211	8b 4c 30 38	 mov	 ecx, DWORD PTR [eax+esi+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream

; 78   :             if (_Rdbuf) {

  00215	85 c9		 test	 ecx, ecx
  00217	74 05		 je	 SHORT $LN100@operator

; 79   :                 _Rdbuf->_Unlock();

  00219	8b 01		 mov	 eax, DWORD PTR [ecx]
  0021b	ff 50 08	 call	 DWORD PTR [eax+8]
$LN100@operator:

; 778  :     return _Ostr;
; 779  : }

  0021e	8b c3		 mov	 eax, ebx
  00220	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00223	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0022a	59		 pop	 ecx
  0022b	5f		 pop	 edi
  0022c	5e		 pop	 esi
  0022d	5b		 pop	 ebx
  0022e	8b e5		 mov	 esp, ebp
  00230	5d		 pop	 ebp
  00231	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00026	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.23.28105\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 950  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 951  :     _Ostr.put(_Ostr.widen('\n'));

  00004	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  00007	6a 0a		 push	 10			; 0000000aH
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
  0000b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000e	03 ce		 add	 ecx, esi
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00016	0f b6 c8	 movzx	 ecx, al
  00019	51		 push	 ecx
  0001a	8b ce		 mov	 ecx, esi
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 952  :     _Ostr.flush();

  00022	8b ce		 mov	 ecx, esi
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 953  :     return _Ostr;

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi

; 954  : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
END
